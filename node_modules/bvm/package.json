{
  "name": "bvm",
  "author": {
    "name": "Matthew Sackman"
  },
  "version": "0.1.9",
  "description": "The BVM",
  "repository": {
    "type": "git",
    "url": "git://github.com/bvm-org/bvm.git"
  },
  "main": "bvm",
  "browserify": "bvm.js",
  "dependencies": {
    "pegjs": "",
    "pretty-data": "",
    "browserify": "",
    "uglify-js": "<2.0.0"
  },
  "devDependencies": {
    "buster": ""
  },
  "scripts": {
    "generate-assembler": "pegjs --cache --track-line-and-column src/assembler.pegjs src/assembler-parser.js",
    "pretest": "npm run-script generate-assembler",
    "test": "buster test --environment node --reporter specification",
    "browserify": "npm run-script generate-assembler && browser/browserify && echo done"
  },
  "readme": "# Table of Contents\n\n- [Introduction](#introduction)\n- [Design Rationale](#design-rationale)\n\t- [The Java Virtual Machine](#the-java-virtual-machine)\n\t- [PostScript](#postscript)\n\t- [Burroughs Large Systems](#burroughs-large-systems)\n- [BVM Installation and Read-Eval-Print-Loop (REPL)](#bvm-installation-and-read-eval-print-loop-repl)\n- [The Architecture of the BVM](#the-architecture-of-the-bvm)\n\t- [Supported Types](#supported-types)\n\t- [File formats](#file-formats)\n\t- [Execution Model](#execution-model)\n\t\t- [Characters](#characters)\n\t\t- [Strings](#strings)\n\t\t- [Literal Arrays](#literal-arrays)\n\t\t- [Literal Dictionaries](#literal-dictionaries)\n\t\t- [Literal Code Segments](#literal-code-segments)\n\t\t- [The Dictionary Stack](#the-dictionary-stack)\n\t\t- [Lexical Addresses](#lexical-addresses)\n\t\t- [Call with Continuation (CALLCC)](#call-with-continuation-callcc)\n\t\t- [Errors](#errors)\n\t\t- [Assembly Labels](#assembly-labels)\n- [BVM Opcode Reference](#bvm-opcode-reference)\n\t- [Operand Stack Manipulation](#operand-stack-manipulation)\n\t- [Addressing](#addressing)\n\t- [Mark](#mark)\n\t- [Arrays](#arrays)\n\t- [Dictionaries](#dictionaries)\n\t- [Code Segments](#code-segments)\n\t- [Dictionary Stack](#dictionary-stack)\n\t- [Control flow](#control-flow)\n\t- [Comparison](#comparison)\n\t- [Logic](#logic)\n\t- [Maths](#maths)\n\t- [Miscellaneous](#miscellaneous)\n- [JavaScript API](#javascript-api)\n\t- [Entry point](#entry-point)\n\t- [The `BVM` object](#the-bvm-object)\n\t- [The `CPU` object](#the-cpu-object)\n\t- [The `Assembler` object](#the-assembler-object)\n\n# Introduction\n\nThe BVM is a stack-based virtual machine, offering a simple and\ncomparatively high-level instruction set. The design does not make any\nassumptions about the paradigm of the language being compiled to the\nBVM, but it does include first-class support for some types of lexical\naddressing, closure capture and automatic tail-calls. These features\naim to decrease the gap between modern languages and the BVM, without\npigeon-holing the BVM to any particular programming paradigm.\n\nWhilst an exhaustive literature review was not possible prior to\ndesigning the BVM, substantial investigation into the design of\nvarious CPUs and VMs (or software-CPUs) was undertaken. These included\nthe world's (suspected) two most popular VMs (PostScript and the JVM)\nalong with rather more obscure (and rather interesting) past CPU\narchitectures.\n\nUltimately, design depends on research, individual thought, and mostly\njudgement. Not all \"neat\" features can be successfully combined\ntogether. Every language has the odd wart (some rather uglier than\nothers!) and beauty is always in the eye of the beholder. However\nwhilst the cyclical reinvention of ideas in computing seems on the\nwhole inescapable, I believe there has been a genuine attempt to learn\nfrom the copious prior art.\n\nWhilst hopefully not limiting the scope of application of the BVM, the\noriginal motivation for the BVM is to enable developers to **not**\nwrite in JavaScript for the browser. The hypothesis is that many\ndevelopers, if given the choice, would prefer not to use\nJavaScript. There are however some important caveats. For example,\nthere are many very good JavaScript libraries that are extremely\npopular and provide functionality specific to the\nbrowser-environment. These should not be shunned or precluded. Thus\nsome aspects of the design of the BVM make it easy for functions to be\nexported, whether they be written in \"native\"-JavaScript or compiled\nto the BVM. Thus one can think of the BVM as attempting to provide a\ncommon-language-runtime and also providing a means of dynamic-linking\nwhich is language agnostic and provides a\nforeign-function-interface. This is in contrast to other efforts such\nas Emscripten which is more focused on translating entire code-bases\nto JavaScript and for example does not, at the time of writing,\naddress linking to preexisting JavaScript libraries.\n\nThe current example implementation is written in JavaScript and is\navailable to run both in web-browsers and under NodeJS. This\nimplementation is currently a little over 5k lines-of-code, including\ncomments and whitespace, and minimises to just 66kB (including\nassembly parser). Whilst lines-of-code is by no means a convincing\nmetric, hopefully it suggests that the design is not particularly\ncomplex, and that implementations of the BVM in other languages should\nbe possible without excessive engineering effort. There is also\nsubstantial potential for optimisations.\n\nUltimately, I hope to see the BVM implemented directly within web\nbrowsers, thus offering the greatest performance possible and a much\nricher and more inclusive programming environment within the browser.\n\n\n# Design Rationale\n\nThe nice thing about designing a virtual machine is that you get to\ndesign a CPU without any hardware limitations. This means options are\nopen to you which would never have been considered (or were seldom\nconsidered) for hardware designs. For example, where do operands come\nfrom and how are they indicated? Most of the time in hardware they\ncome from CPU registers, which are explicitly indicated in the\ninstruction stream. In a VM, they could just come from any arbitrary\nmemory location and the instruction stream include addresses\ninstead. Equally, they could be implicitly taken from an operand\nstack.\n\nNot only is it worth examining existing VM designs, it is worth\nexamining hardware CPU designs and features. Before the domination of\nArm, x86 and MIPS architectures, there were a vast wealth of\ninnovative hardware architectures which are well worth studying. Some\nCPUs were designed specifically to enable the cheap compilation of\ncertain languages. For example, the Burroughs Large Systems were\nspecifically designed to support ALGOL 60, a programming language\nwhich many people at the time said could never be compiled and\nexecuted on computers. ALGOL 60 was the first language implementing\nnested function definitions with lexical scope and closure capture\n(features which were then borrowed by Scheme and many other mainstream\nlanguages). Burroughs built in specific features to the hardware to\nmake compilation easier. The Burroughs Large Systems had, for example,\nhardware support for tracking lexical scopes and allowing symbolic\naddressing of locations in parent scopes, whilst supporting a\ncontinuous operand-and-control-flow stack and without the compiler\nneeding to attempt to calculate explicit stack-relative addresses to\naccess parent lexical scopes.\n\nAnother interesting feature is the use of *register windows*. These\nare widely used in RISC architectures, particularly SPARC, and perhaps\nmost elegantly in the AMD 29k CPU. A register window exposes just a\nsubset of the total available registers to each function, and this\nsubset changes (and is restored) every time you enter (and exit) a\nfunction. This allows for the abstraction of register names: they\nbecome local to each function scope. In SPARC designs, the window is\nfixed size:\n\n> The Sun Microsystems SPARC architecture provides simultaneous\n  visibility into four sets of eight registers each. Three sets of\n  eight registers each are \"windowed\". Eight registers (i0 through i7)\n  form the input registers to the current procedure level. Eight\n  registers (L0 through L7) are local to the current procedure level,\n  and eight registers (o0 through o7) are the outputs from the current\n  procedure level to the next level called. When a procedure is\n  called, the register window shifts by sixteen registers, hiding the\n  old input registers and old local registers and making the old\n  output registers the new input registers. The common registers (old\n  output registers and new input registers) are used for parameter\n  passing. Finally, eight registers (g0 through g7) are globally\n  visible to all procedure levels.\n\nOf course eventually, with enough sub-calls, you could exhaust all the\nregisters on the CPU, and at that point values have to be manually\nspilled out to RAM. The window is essentially an atomic unit in a\nstack containing the stack-allocated values of the current\ncall-chain. The AMD 29k CPU had an elegant modification of this design\nin that the register window is not of fixed size. Thus functions\ndeclared how many registers they needed and this ensured better use of\nthe precious resource that are hardware registers.\n\nIt is worth noting that the MIPS design team examined this design and\nconcluded that register windows were an unnecessarily complex feature\nand that fewer registers but smarter compilers (which made better\ndecisions about the use of registers) were the way forwards. Received\nopinion is that this is true, though it's difficult to find conclusive\nstudies given that there are no two CPUs with the same architecture\nthat differ only in the provision of register windows.\n\nIt is obviously also worth studying VM designs themselves. Some of\nthese are fairly general in nature, whilst others are carefully\ndesigned to match with expected use cases. The JVM, for example,\naccommodates Java very well, whilst accommodating less\nstatically-rigid languages far less well. PostScript contains several\nfeatures and many operators specifically designed for the layout of\ndata on a page. Parrot contains more operators than could ever be\nconsidered reasonable by man or beast. There are however more general\ndesign choices of each that can inform future designs of VMs.\n\n\nOne of the first steps when deciding on a VM design is to decide\nwhether it's going to register-based, whether the operators are going\nto have explicit locations of operands indicated (which could just be\nmemory addresses), or whether it's going to be stack-based and thus\noperands are implicitly taken from the head of the stack.\n\nWhen measured by use, most VMs are stack based. This is due to the\noverwhelming influence of both the JVM, and PostScript which exists in\npretty much every serious printer made. But even if you disregard the\npopularity of these VMs, there seem to be relatively few\nregister-based VMs. There are several reasons for this:\n\n1. The only reason hardware-CPUs have registers is as a means of\nidentifying locations which are valid holders of operands. With a\nsoftware CPU, you don't have this restriction: the operands can come\nfrom anywhere.\n\n2. Hardware CPUs have a limited number of registers. Hardware CPU\nregisters are special high-performance locations. In a modern CPU, a\n*register* is actually an abstracted location as each register will\nexist many times over at most stages within the CPU's pipeline\n(assuming it's a pipelined design). With a software CPU, as you're not\nimplementing a chip, you don't have this limitation. It then seems\nperverse to inflict the issues of register-spilling and management\nonto any compiler targeting your architecture when there's no\nhardware-based reason to have a limited number of registers. Having an\nunbounded number of registers in a VM would complicate the instruction\nset format as the format to indicate which registers are operands\nwould become a little involved. Some register-based VMs such as Parrot\nmake the argument that they can simply map their virtual registers to\nhardware registers. This is true, but complicates implementations of\nthe VM on different architectures with different numbers and types of\nhardware registers. Furthermore, given the evidence of the speed of\nwell optimised stack-based VMs such as the JVM, it would seem a\nregister-based VM is not a necessary precondition for a\nwell-performing VM.\n\n3. Stack-based instruction sets tend to have better code density. This\nis definitely true if you just count *instructions per object-file\nbyte* as all instructions take operands implicitly from the stack(s),\nthus operands are not indicated in the instruction stream. However,\nstack machines do have to include instructions for manipulating the\nstack to make sure the operands are in the correct order on the stack\nfor upcoming instructions. Good compilers can minimise the use of\nthese instructions though you will never eliminate them\nentirely. However, even with a modest sprinkling of such instructions,\nthis is fewer bytes lost to manipulating the stack than bytes lost\nwith register-based CPUs where every single instruction explicitly\nindicates its operands. In a world of mobile devices where bandwidth\ncan often be limited and data transfer billed, this seems a worthwhile\nconcern.\n\nIf we thus decide that stack-based designs are at least more elegant\nand possibly offer a few advantages (whilst requiring optimisation\nefforts to achieve good performance) there are then many further\nissues to consider:\n\n* How many stacks should be used? Some designs separate out the\n  call-stack (i.e. tracking the dynamic control-flow) from operand\n  stacks. Some designs separate out even more: for example PostScript\n  actually has five stacks in use - operand, control-flow, dictionary,\n  graphics-state stack, and clipping path stack - though obviously the\n  last two are very specific to the use of PostScript to construct the\n  layout of data on a page.\n\n* Should the operand stack (and maybe others) be continuous, or\n  distinct: i.e. should all function calls permit modification of the\n  same stack, or should each function call result in an entirely\n  separate stack which merely has a pointer to its parent stack? The\n  continuous design is what people are most used to from e.g. C's use\n  of the stack, but it adds cost to closure capture when the\n  environment of the closure can include stack-based variables and\n  thus sections of the stack then have to be copied out and saved for\n  use by the closure, should it be later invoked. This can get rather\n  complex if the saved environment includes the contents of parent\n  lexical scopes which are then modified elsewhere and perhaps even\n  shared between different closures. For example, in the pseudo code\n\n        var k, x, y, z;\n        x = function () {\n            var j = ...something...;\n            y = function () { ...some use of j... };\n            z = function () { ...some use of j... };\n            return j;\n        };\n        k = x();\n        foo(y);\n        bar(k);\n        return z;\n\n  if the initial creation of `j` is done on the stack and the stack is\n  continuous, then the stack will be popped and `j` will be lost by\n  the time the call to `x()` returns. `k` would then point to a\n  location beyond the top of the stack. The potential subsequent\n  invocations of `y` and `z` will be problematic unless steps are\n  taken to ensure `j` is moved to the heap somewhere and all\n  references to it are updated. Furthermore, whilst the variables `y`\n  and `z` are in the parent scope, the values assigned to them\n  (i.e. the two functions created by `x()`) can also not be created on\n  the stack as they too would be popped once `x()` returns.\n  \n  Alternatively, if each activation frame is an entirely separate\n  stack with merely a pointer to previous stack (thus representing the\n  dynamic control-flow path) then the stack that is created by the\n  invocation of `x()` and containing `j` need not be destroyed when\n  execution returns from `x()`. The values assigned to `y` and `z` are\n  then closures that contain not only their operators, but also\n  pointers to the various activation-frames (or stacks) that are\n  lexically in-scope at the time of declaration of the closure.\n  \n  This however does start to suggest a design focusing more towards\n  lexical scoping rather than dynamic scoping. I believe this is\n  justified though as in a lexically-scoped language, implementing a\n  dynamically-scoped language is fairly straight-forward (there are a\n  number of approaches, but one is simply to have a dictionary which\n  maps variable names to their current value). The opposite however is\n  more involved: implementing a lexically-scoped language within a\n  dynamically scoped one requires keeping many dictionaries mapping\n  variable names to values, preserving some and creating new which\n  inherit from old whenever you enter or exit a function. In my\n  estimation, the majority of popular programming languages today are\n  lexically scoped. Thus a VM which directly supports lexically-scoped\n  languages and offers built-in support for closure capture is\n  advantageous. Furthermore, the provision of these features should\n  not make it more difficult for the VM to be targeted by\n  dynamically-scoped languages nor for languages which do not support\n  first-class functions (and so have no need for closure capture).\n\n* Types. Types always merit much discussion and debate. An instruction\n  set is a language just like any other and so what types it supports\n  and how those types influence semantics are important questions to\n  ask. Some VMs have multiple operators for the same functionality,\n  just on different types of operands. For example, the JVM has\n  `iadd`, `ladd`, `dadd` and `fadd` to perform addition of integers,\n  longs, doubles and floats. Other architectures track the types of\n  values on the stack or in registers implicitly and then overload\n  opcodes so that a single `add` operator will perform the appropriate\n  action dependent on the types of the operands it finds.\n  \n  Some CPUs have opcodes to perform sophisticated matrix operations\n  which you could argue suggests they support a data type of a\n  matrix. Similarly, some modern CPUs have opcodes to explicitly\n  search strings. Other designs support more abstract data types\n  directly, such as arrays and dictionaries. The more you think about\n  a VM as being little different from just another programming\n  language, the more it ceases to seem odd that a VM should support\n  richer data-structures such as collections.\n  \n  However, the greater the sophistication of the types supported, the\n  more carefully you need to design and manage memory use and opcodes\n  for manipulating these data types. For example, if you support some\n  kind of a dictionary in a stack machine, is a dictionary just a\n  plain value, or is it a pointer to a dictionary? If the latter, do\n  you need distinct opcodes to clone the dictionary rather just copy\n  the point to it? Is the raw memory in which the dictionary is stored\n  accessibly directly through some sort of heap, or is the memory of\n  the dictionary and the heap distinct? Can you have both - i.e. if\n  you start with a pointer to a dictionary, can you *load* that\n  pointer in some way and then have the plain value in the operand\n  stack? What advantages would that give you?\n\n## The Java Virtual Machine\n\nThe JVM is a stack-based VM. It mainly uses 1 byte per opcode in its\ninstruction stream which is taken from its class-file format. The\nclass-file format contains other elements such as a constant-look-up\ntable which allows constants (for example strings) to be removed from\nthe instruction stream in order facilitate reuse and other\noptimisations. Some instructions do have further operands taken from\nthe instruction stream. These tend to point to the fact that the JVM\nwas designed with little more than the needs of the Java language in\nmind. So for example, because Java does closed-world compilation, all\nmethod invocation can be resolved at compile-time. This means that\nthere is never a need to try and look up a method based on the name on\nthe top of the stack: as all method names are known at compile-time,\nthey are held in the class-file constant table, and then all method\ninvocation opcodes take from the instruction-stream indices into the\nclass-file constant table to identify the method name. Only the\n*receiver* of the method invocation (i.e. the object) is dynamic and\nthus taken from the stack. Another example is that there's no direct\nheap access at all: everything's couched in terms of objects.\n\nThe JVM supports multiple threads. Each thread has its own stack of\nframes. A frame contains the state of a method invocation. Java has\n*primitive* values (such as numbers, booleans) which are held directly\nin stack frames. Reference values (including arrays and objects) are\nalways created and held in the heap, and pointed to from stack\nframes. Whilst stacks are continuous, there is no way to access the\ncontents of a parent stack frame. Because methods are attached to\nobjects and objects are always held in the heap, the closure capture\nissues outlined above are first reduced and then eliminated by\npermitting only access to constants in parent lexical scopes from\nwithin a new closure. Method signatures are known at compile-time and\nso method invocation removes the correct number of arguments from the\ncurrent stack frame and supplies them to the new stack frame. There\nare explicit `return` instructions to return values to the calling\nstack. As mentioned above, JVM byte-code does not embrace overloaded\nopcodes: just as there are many different forms of `add` there are\nalso different forms of `return` depending on the type of the value\nbeing returned. It strikes me that this is a little odd given that the\nmethod signature which is known at compile-time and used to determine\nthe number of arguments to a method (and verify their type) would also\nindicate the type of the returned value, thus a single `return`\ninstruction would suffice. However, it's possible this asymmetry is\nboth intentional and necessary and I'm missing something.\n\n## PostScript\n\nPostScript is an extremely elegant stack-based design. The instruction\nstream is just text: there is no binary instruction stream, though\nthere is support for compression of the instruction stream. It is\ninteresting to consider whether there is any benefit these days to a\nVM supporting a custom binary-format given how widely supported *gzip*\ncompression, especially of text, has become. The language supports\narrays (both packed (read-only) and unpacked) and dictionaries. A\nstring in the instruction stream that is not recognised as an opcode\nis used as a key to index a stack of dictionaries. If a value is found\nand that value is a user-declared function then the function is\nrun. Thus there is no real distinction between opcodes and\nuser-defined functions. There is even a form of `eval` where a string\ncan be reinterpreted as a stream of opcodes.\n\nPostScript supports some rather high-level operators such as mapping\nover elements of arrays and explicit `for`-loop support. PostScript is\na dynamically-scoped language and has contiguous stacks: when you call\na function, that function can perform any manipulation it likes of all\nthe stacks: there is no facility to indicate exactly how many operands\na function should take, and there is also no explicit `return`\noperator: control flow returns to the calling function when there are\nno more opcodes in the current function. Because of this contiguous\noperand stack, the call stack must be a separate stack to avoid\nfunctions coming across and manipulating function-call on the operand\nstack.\n\nThere are also no explicit branching (in the sense of `jump`)\nopcodes. Opcodes such as `if`, `loop` etc are supported explicitly and\ntake functions as arguments.\n\n## Burroughs Large Systems\n\nAs mentioned previously, Burroughs Large Systems were computers with\nan architecture specifically designed for the execution of ALGOL\n60. They had a contiguous operand-and-control-flow stacks and a novel\nform of lexical addressing. This allowed expressions such as \"the\nsecond item in the stack of my lexical grand-parent\".\n\nWhen a function was invoked, as normal, the stack would record the\nprevious stack frame marker along with the address of the next\ninstruction once the callee has returned. The function to call would\nbe indicated by a pointer which would be an offset within the\nstack-frame in which the function was declared. This allows the parent\nlexical scope to be established (i.e. the parent lexical scope is the\nscope in which the function is declared). From the stack frame marker\nof the parent lexical scope, you can find the function that led to\nthat stack frame being created and thus the lexical scope of that\nfunction declaration, and so forth. In fact, these machines supported\na hardware-based array of 32 elements which were explicitly set on\nfunction invocation and return to point to all the parent lexical\nscopes. Thus you could then very cheaply access your parent scopes:\nelement 0 in this array would point to the scope of the root, 1 to its\nchild, and so on up to the current lexical scope, *N*.\n\nThus the Burroughs Large Systems support not only a stack which tracks\nthe dynamic control flow, but also permits function declaration on the\nstack which can then be used to establish the lexical scopes of each\nfunction upon invocation.\n\nThe Burroughs Large Systems were 51-bit architectures. Each value on\nthe stack could be up to 48-bits, and had a 3-bit tag indicating the\noperand's type. Opcodes were then allowed to be overloaded based on\nthe types of values found on the stack. There were also explicit\noperators to facilitate call-by-value and call-by-reference, both of\nwhich were supported by ALGOL 60. The stack itself was held in RAM,\nnot on the CPU in any sort of CPU-local hardware stack, apart from the\ntop two values of the stack which were two registers within the CPU\nitself.\n\n\n# BVM Installation and Read-Eval-Print-Loop (REPL)\n\nThe JavaScript implementation comes with a REPL that works both in\nweb-browsers and in NodeJS.\n\nTo download:\n\n    $ git clone https://github.com/five-eleven/bvm.git\n    $ cd bvm\n    bvm$ npm install\n\nThen, to start the REPL under NodeJS:\n\n    bvm$ node -e \"require('./bvm').repl();\"\n    bvm>\n\nTo prepare the REPL for a browser:\n\n    bvm$ npm run-script browserify\n\nThen point your web browser at the `bvm/browser/index.html` file.\n\n\n# The Architecture of the BVM\n\nThe BVM is a stack-based virtual machine. There are function-distinct\ncall-and-operand stacks, and a separate dictionary stack which is used\nfor both error handling and to export functions. By making the\nfunction call-and-operand stacks distinct, the closure capture is\ntrivially supported. Whilst the VM is currently single-threaded, there\nis no requirement for real threads to be precluded, and the VM has\nbuilt-in support for call-with-continuation which can be used both for\nerror-handling (i.e. `try-catch`) and also to build a micro-kernel /\nscheduler which could implement green-threads.\n\n## Supported Types\n\nThe BVM has built-in support for the following types:\n\n* Numbers. Currently these are required to be 64-bit floats. This will\n  almost certainly be revised to support 32-bit integers (and possibly\n  64-bit integers too).\n\n* Booleans.\n\n* Arrays. Arrays are dynamically sized and are a reference type:\n  multiple values can point to the same array.\n\n* Characters.\n\n* Strings. These are treated as arrays of characters.\n\n* Dictionaries, where the keys must be strings. This restriction may\n  be relaxed in the future. Dictionaries are of dynamic size and are a\n  reference type like Arrays.\n\n* Code Segments. These contain both opcodes and an understanding of\n  the lexical scope in which they were declared. Throughout this\n  document, the terms \"code segment\" and \"function\" are frequently\n  used interchangeably.\n\n* Lexical Addresses. These can be literals (i.e. constants) in the\n  instruction stream, or they can be constructed dynamically. They\n  represent an offset into a lexical context in scope at the time of\n  the current function declaration. Once a lexical address enters the\n  operand stack (in non-*deferred mode*), it is *fixed* which ensures\n  that it is stable: i.e. the lexical address itself can be passed to\n  different functions declared in different scopes and the lexical\n  address will continue to point at the same offset in the very same\n  stack.\n\n* Stacks. A stack is seldom witnessed as a value on the operand stack.\n  It appears though when some form of call-with-continuation\n  (`CALLCC`) occurs and thus then represents a suspension of\n  execution. A stack contains the current state of a segment\n  invocation and along with pointers to the relevant code segment (and\n  internal offset: i.e. instruction pointer), the calling stack\n  (i.e. dynamic call chain), and the stack of its lexical parent scope\n  (this is the same lexical scope information that is held by the\n  stack's code segment itself).\n\n* Various singleton types such as `undefined` and `mark`. `undefined`\n  is a bottom value. `mark` is used to act as a marker on the operand\n  stack and is used both implicitly and explicitly by various opcodes.\n\n## File formats\n\nThe object file format is a JSON array, with no encoding of opcodes at\nall: they exist as literal strings. There is a light encoding of some\nfeatures such as characters (as JSON cannot distinguish between\nstrings of length 1 and characters), and lexical addresses. JSON is\nchosen because of its widespread support in browsers and the ease of\ncompression: standard compression techniques are expected to lead to\nfile sizes as small as efficient binary object file formats. The\nnon-binary format is also in the spirit of the \"open web\" and should\nalso lead to a very low curve to creating tool chains and debugging\ninfrastructure. The only downside is that it is likely the entire\nobject file will need to be downloaded before decompression and\nexecution can begin. If in practise this becomes an issue, this can be\nrevisited.\n\nThe assembly format is plain text, with whitespace-separated\ntokens. The assembly format permits comments. The parser currently\nenforces some constraints (such as correct pairing of literal array,\ndictionary and segment declarations) which are not strictly necessary\nthough in practise it is not anticipated these restrictions will cause\nany difficulties for users of the assembler. The assembly format\nhowever does support some very useful shorthands and is less\nsyntactically noisy than writing the JSON object file format\ndirectly. As mentioned above, the example implementation in\nJavaScript, including the assembler, minimises to 60kB. Given this, it\nmight actually be preferable to ship the bundle including the\nassembler to browsers and then treat the assembly itself as the object\nformat. It remains to be seen which is more convenient or\nattractive. The arguments made previously about compression are just\nas valid when applied to the assembly format.\n\nAll examples given in this document are given in the assembly\nformat. The documentation of the opcodes however gives both assembly\nand object file format representations.\n\n## Execution Model\n\nExecution is relatively standard for a stack machine: an opcode is\nfetched from the current instruction pointer. The instruction pointer\nis incremented. The fetched opcode is interpreted. As usual with stack\nmachines, operation in Reverse Polish Notation form: thus in general,\nyou first set up the operands on the stack, and then you call the\noperator. The operators, or opcodes, often expect to find further\nvalues on the top of the stack. These values will be removed from the\nstack, and often the result of the opcode will be pushed onto the\nstack when the operator completes.\n\nThe only exception to this general strategy is the `PUSH` opcode,\nwhich causes the following element from the current segment's\ninstruction stream to be placed onto the operand stack. In all other\ncases, arguments to opcodes come from the operand stack, not the\ninstruction stream.\n\nNote that all opcodes are case sensitive and all the built-in opcodes\nare in UPPERCASE. So, to add together the numbers 3 and 5, we can\nwrite:\n\n    bvm> PUSH 3 PUSH 5 ADD\n    {\"type\": \"stack\",\n     \"lsl\": 0,\n     \"ip\": {\"type\": \"ip\",\n            \"segment\": {\"type\": \"segment\",\n                        \"instructions\": [\"PUSH!\", 3, \"PUSH!\", 5, \"ADD!\"]},\n            \"index\": 5},\n     \"contents\": [8]}'\n\nThe default action of the REPL is to display the result of the\nsupplied instructions or, if there is no explicit result, to display\nthe final state of the stack. To explicitly return a result, we use\nthe `RETURN` opcode, which requires an argument on the stack telling\nit how many subsequent elements from the stack to return to the\ncalling function (or in the case of the *root* function of the REPL,\nhow many elements to display back to us). The simplest thing is to\nreturn everything on the stack, which means we must push a number\nwhich is the current height of the stack. There's an operator for\nthat: `COUNT`.\n\nSo we get much more readable results if we do:\n\n    bvm> PUSH 3 PUSH 5 ADD COUNT RETURN\n    [8]\n\n> Because every function can return a variable number of results,\n> results will always be displayed in an array, even though in this\n> case, we've only returned a single result. The left-hand-end of the\n> array is always the *bottom* of the stack (also the *first item in\n> the stack*, or the *item at index 0 in the stack*). The\n> right-hand-end of the array is always the *top* of the stack (thus\n> also the *last item in the stack*, etc). Note that because the\n> current BVM implementation is written in JavaScript, the results\n> returned and displayed by the REPL are JSON-formatted data objects\n> and thus differ in format from the input of BVM assembly. For\n> example, BVM assembly requires whitespace separators, whereas JSON\n> tends to remove whitespace where other separators must be used, for\n> example `,` and `:` in arrays and objects. Because JSON can't cope\n> with cycles in data structures, quite often when trying to display a\n> stack (which often contain cyclical pointers), JSON will fail and\n> you'll get a `Error: TypeError: Converting circular structure to\n> JSON` error. This does not mean there's anything wrong with your BVM\n> program, just that the result of the program can not be successfully\n> converted to JSON.\n\nIf we do:\n\n    bvm> PUSH 13 PUSH 3 PUSH 5 ADD COUNT RETURN\n    [13, 8]\n\nwe see that the `ADD` only affects the uppermost two elements of the\nstack and the `13` is left alone. `COUNT` will then find there are two\nelements on the stack and so will push the number `2`. `RETURN` will\nthen find that `2` and will then grab the next two elements from the\nstack and return them to us.\n\nIn the BVM, when multiple values are moved around, for example by the\n`RETURN` opcode (and others introduced in due course), order is always\npreserved. So at item at the top of the stack becomes the item at the\ntop of the new stack to which it's been moved.\n\nThere is an **implicit default operator**. This is overloaded and will\nbe explained part by part. When an opcode is encountered which is not\na built-in opcode, this default operator is invoked. *If the opcode\nencountered is a number (or a character), the number will be pushed\nonto the operand stack.* Thus we can rewrite the above as:\n\n    bvm> 13 3 5 ADD COUNT RETURN\n    [13, 8]\n\nThat's rather a lot shorter.\n\nThere is no difference between a string and an opcode. In the above\nexamples, `ADD` is just a string that is recognised as the name of an\nopcode. If we wish to push the string \"ADD\" onto the stack rather than\ninvoke the function associated with that string, then we must\nexplicitly use `PUSH`:\n\n    bvm> 13 3 5 PUSH ADD COUNT RETURN\n    [13, 3, 5, \"ADD\"]\n\nYou only need to use quotes in the program text when a string has\nspaces in it:\n\n    bvm> 13 3 5 PUSH \"ADD this\" COUNT RETURN\n    [13, 3, 5, \"ADD this\"]\n\nBut it's not an error to use quotes where they're not necessary. Note\nthat only \"double quotes\" are allowed for strings:\n\n    bvm> 13 3 5 \"PUSH\" \"ADD this\" \"COUNT\" \"RETURN\"\n    [13, 3, 5, \"ADD this\"]\n\n### Characters\n\nA character is indicated in assembly by surrounding the character with\nsingle quotes. As mentioned above, when encountered as an opcode, the\n**implicit default operator** will just push the character onto the\noperand stack. Note that because neither JavaScript or JSON can\ndistinguish between a character and a string of length 1, display of\ncharacters in the current JavaScript implementation is a little\nverbose:\n\n    bvm> 'a' PUSH 'b' PUSH \"c\" COUNT RETURN\n    [{\"type\":\"character\",\"character\":\"a\"}, {\"type\":\"character\",\"character\":\"b\"}, \"c\"]\n\nNote the difference between pushing a string (of length 1) and pushing\na character. Again, due to difficulties with JavaScript and JSON, in\nthe JSON object format, a character must be encoded. The encoding is\nto make the character into a string, and place that string inside an\narray. Thus the above example is encoded as:\n\n    [ [ 'a' ], 'PUSH', [ 'b' ], 'PUSH', 'c', 'COUNT', 'RETURN' ]\n\nObviously, additional confusion is caused by JavaScript not\ndistinguishing between single and double quotes!\n\n### Strings\n\nA string is just an array of characters. In both the assembly and\nobject formats, literal strings can occur freely. Once a string enters\nthe operand stack, it becomes an array of characters. The current\nimplementation will display an array as if it is a string if all the\nelements of the array are characters. You can of course thus use the\nentire array API to manipulate \"strings\".\n\nNote that because arrays are a reference type, when strings are used\nas the keys of dictionaries (more on this later), the dictionary will\ntake a copy of the string. This ensures that if you modify the string\nafter using it as a key in a dictionary, you are not actually\nmodifying the same string as being used by the dictionary.\n\n### Literal Arrays\n\nA literal array can be created by using the `[` and `]` opcodes. Note\nthat these are an *assembly shorthand* for `ARRAY_START` and\n`ARRAY_END` opcodes. The shorthands are not valid in the object file\nformat. The `ARRAY_START` opcode simply places a marker on the\nstack. Execution then continues as normal (further opcodes are\ndirectly evaluated as normal) until the `ARRAY_END` opcode is\nencountered. This searches back down through the stack until it finds\nthe mark, and then takes all the contents between and uses it to\npopulate a fresh array, finally placing that array back onto the\nstack.\n\n    bvm> [ ] COUNT RETURN\n    [[]]\n    bvm> [ 1 16 3 ] COUNT RETURN\n    [[1, 16, 3]]\n    bvm> [ PUSH 1 PUSH 16 PUSH 3 ] COUNT RETURN\n    [[1, 16, 3]]\n    bvm> [ PUSH 1 PUSH 16 PUSH 3 ADD ADD ] COUNT RETURN\n    [[20]]\n    bvm> [ 1 16 3 ADD ADD [ PUSH hello ] ] COUNT RETURN\n    [[20, [\"hello\"]]]\n\nThe full array API including dynamic array creation is covered later.\n\n### Literal Dictionaries\n\nA literal dictionary can be created by using the `<` and `>`\nopcodes. As with arrays, these are *assembly shorthands* for the\nopcodes `DICT_START` and `DICT_END`, and the shorthands are not valid\nin the object file format. As with arrays, the `START` simply places a\nmarker onto the stack, execution continues as normal until the\n`DICT_END` opcode is encountered.\n\nWhen `DICT_END` is encountered, it is required that there are an even\nnumber of elements on the stack between the starting marking and the\ntop of the stack indicating pairs of keys and values. All keys must be\nstrings.\n\n    bvm> < PUSH hello 5 PUSH goodbye 17 > COUNT RETURN\n    [{\"hello\": 5, \"goodbye\": 17}]\n    bvm> < PUSH hello 5 DEC PUSH goodbye 17 3 ADD > COUNT RETURN\n    [{\"hello\": 4, \"goodbye\": 20}]\n    bvm> < PUSH hello 5 DEC PUSH goodbye 17 3 ADD PUSH foo [ 1 3 5 ] > COUNT RETURN\n    [{\"hello\": 4, \"goodbye\": 20, \"foo\": [1, 3, 5]}]\n\nThe full dictionary API including dynamic dictionary creation is\ncovered later.\n\n### Literal Code Segments\n\nA *code segment* can be created by using the `{` and `}` opcodes. Once\nagain, these are assembly shorthands for `SEG_START` and `SEG_END`,\nand the shorthands are not valid in the object file format. Note that\nbetween a `SEG_START` and a `SEG_END`, *no evaluation takes place*:\nevaluation is said to be in *deferred mode* (to borrow terminology\nfrom PostScript). This is in contrast to the behaviour between `[` and\n`]`, and `<` and `>` where evaluation does continue. When in *deferred\nmode*, opcodes are simply pushed onto the operand stack (conceptually\nat least. There's actually no need for implementations to behave this\nway). When *deferred mode* is exited (by finding a corresponding\n`SEG_END`), the opcodes pushed to the operand stack are removed and\nformed into a *code segment*. There are then several ways to invoke a\nsegment on the top of the stack, the most obvious of which is the\n`EXEC` opcode.\n\n    bvm> { 3 5 ADD } COUNT RETURN\n    [{\"type\": \"segment\",\n      \"ls\": {\"type\": \"stack\",\n             \"lsl\": 0,\n             \"ip\": {\"type\": \"ip\",\n                    \"segment\": {\"type\": \"segment\",\n                                \"instructions\": [\"SEG_START!\", 3, 5, \"ADD\", \"SEG_END!\", \"COUNT!\", \"RETURN!\"]},\n                    \"index\": 7},\n             \"contents\": []},\n      \"instructions\": [3, 5, \"ADD\"]}]\n\nNote here the final line which shows the instructions within the newly\ncreated segment: it shows the literal contents between the `{` and `}`\nopcodes, demonstrating that evaluation of the segment has not yet\ntaken place.\n\n    bvm> { 3 5 ADD } EXEC COUNT RETURN\n    []\n\nHere, whilst we now caused the created segment to be evaluated, that\nsegment returned no results. Whilst there would have been an 8 sitting\non its stack before control returned to the enclosing code, there\nneeds to be an explicit `RETURN` opcode if you wish to pass any values\nback to the caller.\n\n    bvm> { 3 5 ADD COUNT RETURN } EXEC COUNT RETURN\n    [8]\n    bvm> { 17 3 5 ADD COUNT RETURN } EXEC COUNT RETURN\n    [17, 8]\n    bvm> PUSH hello { 17 3 5 ADD COUNT RETURN } EXEC COUNT RETURN\n    [\"hello\", 17, 8]\n    bvm> PUSH hello { 17 3 5 ADD COUNT RETURN } EXEC 2 RETURN\n    [17, 8]\n\nThe BVM can automatically detect tail calls. If, at the point of\ninvocation of a code segment it is found that there are *no further\ninstructions in the current code segment*, then a tail call is\nperformed. This then means that you can delegate to a callee which\nvalues are returned to your own caller (the following example makes\nsense if you consider that the REPL itself is the caller to the\nouter-most code, and thus that code is delegating (via a tail-call to\nthe declared code segment) which and how many values are returned to\nthe REPL):\n\n    bvm> { 17 3 5 ADD COUNT RETURN } EXEC\n    [17, 8]\n\nIf you deliberately want to avoid any values being returned, you can\nuse `0 RETURN` as you'd expect (though this is obviously no longer a\ntail-call).\n\n    bvm> { 17 3 5 ADD COUNT RETURN } EXEC 0 RETURN\n    []\n\nSegments must use `RETURN` to pass values back to their caller because\nof the fact that operand stacks are distinct: each function invocation\ngets a fresh empty stack. In order to pass values into a function, the\ncalling function simply leaves the values on its own stack, and the\ncallee may access them using the `RETURN`-symmetric `TAKE`\nopcode. Just like with `RETURN`, `TAKE` requires a numeric argument on\nthe current stack to indicate how many values to remove from the\ncalling stack. Note that values are removed and not simply copied.\n\n    bvm> 3 5 PUSH \"hello\" { 3 TAKE } EXEC COUNT RETURN\n    []\n    bvm> 3 5 PUSH \"hello\" { 3 TAKE COUNT RETURN } EXEC COUNT RETURN\n    [3, 5, \"hello\"]\n    bvm> 3 5 PUSH \"hello\" { 3 TAKE COUNT RETURN } EXEC // tail call\n    [3, 5, \"hello\"]\n    bvm> 3 5 PUSH \"hello\" { 2 TAKE COUNT RETURN } EXEC COUNT RETURN\n    [3, 5, \"hello\"]\n    bvm> 3 5 PUSH \"hello\" { 2 TAKE COUNT RETURN } EXEC\n    [5, \"hello\"]\n\nThere is also a `TAKE_COUNT` to allow you to dynamically determine the\nmaximum number of values you may take (or in other words, this pushes\nto the current stack the height of the stack of the caller).\n\n    bvm> 3 5 PUSH \"hello\" { TAKE_COUNT TAKE COUNT RETURN } EXEC\n    [3, 5, \"hello\"]\n    bvm> 3 5 PUSH \"hello\" { TAKE_COUNT TAKE POP ADD COUNT RETURN } EXEC\n    [8]\n\n> The stack that you remove values from by the use of `TAKE` is\n> referred to as the *take-stack*. This is normally the stack of your\n> caller, but not always. This gets more interesting much later on\n> with the discussion of call-with-continuation.\n\nSegments are first-class values, so for example, you can return them\nfrom other segments:\n\n    bvm> { { 6 8 ADD 1 RETURN } 1 RETURN } EXEC EXEC\n    [14]\n    bvm> 6 8 { 3 5 { 2 TAKE ADD 1 RETURN } 1 RETURN } EXEC EXEC\n    [14]\n\nThis last one demonstrates that `TAKE` operates on the dynamic calling\nstack, and not on the lexical scope.\n\n### The Dictionary Stack\n\nThe dictionary stack is a built-in stack of dictionaries. Unlike the\noperand stack, the dictionary stack is continuous: every function gets\nto see the same dictionary stack and all can manipulate it as they see\nfit. The dictionary stack can be used for anything, but it is expected\nto be used for the following:\n\n* Exporting functions and creating name-spaces. As functions are\n  first-class values, they can be stored as values in dictionaries\n  against the function names as keys. You could then create a new\n  dictionary containing all of your library's exported functions, and\n  then store that dictionary in the dictionary stack under the\n  library's name.\n\n* Error handling. Upon encountering an error, the BVM looks in the\n  dictionary stack searching for a value stored against the error name\n  as a key. If it finds it and if the value is a code segment, the\n  segment is invoked. This is the reason why the dictionary stack is a\n  stack and not just a single dictionary: it is expected that\n  higher-level languages convert `try-catch` blocks into:\n    1. Create a new dictionary\n    2. Populate it with keys and values representing the error names\n      and `catch`-blocks.\n    3. Push this dictionary to the top of the dictionary stack.\n    4. Run the code inside the `try-catch` block.\n    5. In all cases, whether errored or not, pop the dictionary stack\n      after the code inside the `try-catch` block has run.\n\nThe dictionary stack also plays a role in the **implicit default\noperator**. If the opcode encountered is a string, the string is used\nas a key to search the dictionary stack. If a value is found and that\nvalue is a code segment, the code segment is invoked. If a value is\nfound and the value is not a code segment, the value is just pushed\nonto the stack.\n\nWhilst the complete dictionary stack API is covered later, for the\nmoment we shall look at the opcodes `LOAD` and `STORE`. These are\noverloaded operators and shall be covered in full detail\nlater.\n\n* `LOAD` expects to find an address at the top of the operand\nstack. If that address is a string then the string is used as a key to\nsearch through the dictionary stack looking for a value. The first\nvalue that is found is pushed onto the stack. If no value is found,\nthen `UNDEF` is pushed onto the stack.\n\n* `STORE` expects to find a value at the top of the operand stack\nand an address beneath it. If that address is a string, then the value\nis stored in the uppermost dictionary on the dictionary stack under\nthe address.\n\nSome examples:\n\n    bvm> PUSH hello 5 STORE COUNT RETURN\n    []\n    bvm> PUSH hello 5 STORE PUSH hello LOAD COUNT RETURN\n    [5]\n    bvm> PUSH hello 5 STORE PUSH foo 17 STORE PUSH foo LOAD COUNT RETURN\n    [17]\n    bvm> PUSH hello 5 STORE PUSH foo 17 STORE PUSH bar LOAD COUNT RETURN\n    [\"undef\"]\n\nIf we now make use of the implicit default operator, we can make these\nexamples smaller:\n\n    bvm> PUSH hello 5 STORE hello COUNT RETURN\n    [5]\n    bvm> PUSH hello 5 STORE PUSH foo 17 STORE foo COUNT RETURN\n    [17]\n    bvm> PUSH hello 5 STORE PUSH foo 17 STORE bar COUNT RETURN\n    [\"undef\"]\n\n    bvm> PUSH eight { 8 1 RETURN } STORE eight COUNT RETURN\n    [8]\n    bvm> PUSH eight { 8 1 RETURN } STORE eight // tail call\n    [8]\n    bvm> PUSH my_add { 2 TAKE ADD 1 RETURN } STORE 3 7 my_add\n    [10]\n\nIt should now be clear there is no difference between invoking a\nfunction stored in the dictionary stack and any other opcode. If you\ndo have a function stored in the dictionary stack, sometimes you might\nwant to load it explicitly rather than the default loading and\ninvoking:\n\n    bvm> PUSH eight { 8 1 RETURN } STORE PUSH eight LOAD COUNT RETURN\n    [{\"type\": \"segment\",\n      \"ls\": {\"type\": \"stack\",\n             \"lsl\": 0,\n             \"ip\": {\"type\": \"ip\",\n                    \"segment\": {\"type\": \"segment\",\n                                \"instructions\": [\"PUSH!\", \"eight\", \"SEG_START!\", 8, 1, \"RETURN\", \"SEG_END!\",\n                                                 \"STORE!\", \"PUSH!\", \"eight\", \"LOAD!\", \"COUNT!\", \"RETURN!\"]},\n                    \"index\": 13},\n             \"contents\": []},\n      \"instructions\": [8, 1, \"RETURN\"]}]\n\nOnce we have that code segment back on the stack, we can `EXEC` it as\nusual:\n\n    bvm> PUSH eight { 8 1 RETURN } STORE PUSH eight LOAD EXEC COUNT RETURN\n    [8]\n    bvm> PUSH my_add { 2 TAKE ADD 1 RETURN } STORE 6 7 PUSH my_add LOAD EXEC\n    [13]\n\nAnd to reinforce the idea that there's really no difference between\nopcodes and user-defined code segments, we can even load opcodes onto\nthe stack:\n\n    bvm> 6 7 PUSH ADD LOAD EXEC COUNT RETURN\n    [13]\n\nThough you don't get to actually look inside the implementation of\nopcodes unlike with user-defined code segments:\n\n    bvm> PUSH ADD LOAD COUNT RETURN\n    [\"ADD!\"]\n\nThis reveals then the trade-off between allowing more than just\nstrings as keys in dictionaries: if, for example numbers were allowed\nas keys, then due to the implicit default operator, all literal\nnumbers in the source text would have to be explicitly `PUSH`ed onto\nthe stack as by default they would be used as keys to index the\ndictionary stack.\n\nThe rest of the dictionary stack API (including actually adding and\nremoving dictionaries from this stack) will be covered later.\n\n### Lexical Addresses\n\nThe BVM allows code segments to explicitly index any lexical\nscope. The assembly syntax for this is `(A, B)` where `A` is the\n*lexical scope level*, and `B` is the *stack index* within that\nlevel. The *lexical scope level* is 0 for the root scope, 1 for all\nchildren of the root, and so on. The *stack index* 0 refers to the\nfirst item at the *bottom* of the relevant stack. The JSON object file\nformat is `[A, B]`. Note the array must always have two elements.\n\nThe **implicit default operator** also plays a role with lexical\naddresses: if an opcode is encountered which is a lexical address and\nthe value pointed to by the lexical address is a code segment, then\nthat code segment is invoked. If the opcode encountered is a lexical\naddress which points at a value other than a code segment, the value\nis simply pushed onto the stack. Note that the location pointed to by\nthe lexical address is not modified, thus where the value found is a\nreference value (i.e. an array, dictionary, segment or stack), the\nvalue is shared: i.e. a new reference to the same underlying value is\npushed to the stack rather than any cloning of the underlying value\ngoing on. These are the same semantics as with an unknown string as an\nopcode and indexing into the dictionary stack: it's just you're\nindexing via your lexical scopes rather than the dictionary stack.\n\n    bvm> 5 (0, 0) COUNT RETURN\n    [5, 5]\n    bvm> 5 7 (0, 0) COUNT RETURN\n    [5, 7, 5]\n    bvm> 5 7 (0, 1) COUNT RETURN\n    [5, 7, 7]\n    bvm> 13 { 12 (0, 0) COUNT RETURN } EXEC COUNT RETURN\n    [13, 12, 13]\n    bvm> 13 { 12 (1, 0) COUNT RETURN } EXEC // tail call\n    [12, 12]\n\n`EXEC` removes the segment itself from the stack, whereas lexical\naddresses leave the original value in tact, which can be very useful\nfor example for recursive functions.\n\n    bvm> 13 { 12 (1, 0) COUNT RETURN } (0, 1) (0, 0) COUNT RETURN\n    [13, {\"type\": \"segment\", /* rest elided */ }, 12, 12, 13]\n\nThere are three shorthands that are permitted with regards to lexical\naddresses but these shorthands differ slightly between the assembly\nand the object format. The first is to omit the *lexical scope level*\nentirely, thus the syntax is then just `(B)`. This implies the current\nlexical scope. The following are equivalent:\n\n    bvm> 13 { 17 (1, 0) (0, 0) (1, 1) COUNT RETURN } (0, 1)\n    [17, 17, 13, 17]\n    bvm> 13 { 17 (0) (0, 0) (1) COUNT RETURN } (1)\n    [17, 17, 13, 17]\n\nFor the object format, the JSON array must specify `undefined` (or\n`null`) as the first value, so for example `(3)` would be encoded as\n`[undefined, 3]`.\n\nThe second shorthand is to use negative numbers as the *lexical scope\nlevel*. -1 indicates your parent, -2 is your grandparent, and so\non. It's important to remember though that 0 is always the root\nlexical scope - if you want to indicate the current scope simply, omit\nthe *lexical scope level* entirely (thus using the first\nshorthand). Thus the following are again equivalent:\n\n    bvm> 13 { 17 (1, 0) (0, 0) (1, 1) COUNT RETURN } (0, 1)\n    [17, 17, 13, 17]\n    bvm> 13 { 17 (0) (0, 0) (1) COUNT RETURN } (1)\n    [17, 17, 13, 17]\n    bvm> 13 { 17 (0) (-1, 0) (1) COUNT RETURN } (1)\n    [17, 17, 13, 17]\n\nFor the object format, the negative *lexical scope level* is permitted\ndirectly.\n\nThe third shorthand is to use negative numbers as the *stack\nindex*. Here, `-1` means the top of the stack, `-2` means the item\nbelow, and so forth. However, note that when a lexical address is used\nor pushed onto the current operand stack, not only is the stack\nresolved and fixed, but so is the index, so a negative *stack index*\nwill be rewritten to a positive index. This makes it stable in case\nthe stack changes length in the future. For example:\n\n    bvm> 5 13 { PUSH (0, -1) 1 RETURN } EXEC 6 (-2) LOAD 2 RETURN\n    [6, 13]\n\nThe inner code segment returns a lexical address which has now been\nfixed to point at the 2nd item in the parent scope's stack. Thus even\nthough we then push `6` to the stack, duplicating the lexical address\n(with the `(-2)`) and `LOAD`ing it still loads the `13`, not the\n`6`. I.e. the `-1` was rewritten to a `1` when the `(0, -1)` lexical\naddress was pushed onto the operand stack.\n\nFor the object format, again, the negative *stack index* is permitted\ndirectly.\n\nLexical addresses, as you would expect, are referenced based on the\nscope of the declaration of the function, not the scope in which the\nfunction is eventually evaluated. For example, note the following\nreturns `3` and not `1` - the innermost code segment is returned as a\nvalue all the way to the root segment where it is finally\nevaluated. But its parent lexical scope is the scope in which that\nfunction was declared - i.e. the scope which first pushes `3` to its\nstack.\n\n    bvm> 1 { 2 { 3 { (-1, 0) 1 RETURN } 1 RETURN } EXEC } EXEC EXEC\n    [3]\n\nJust like with strings, lexical addresses can be explicitly `PUSH`ed\nonto the operand stack to avoid the implicit default operator. Once\nthere, they can act as addresses for the `LOAD` and `STORE` opcodes:\n`LOAD` just takes an address off the operand stack and pushes back on\nthe value found at that address, whilst `STORE` expects to find a\nvalue at the top of the stack, and an address next. When the addresses\nare strings, `LOAD` and `STORE` manipulate the dictionary stacks, but\nwhen the addresses found are lexical addresses they modify the\nrelevant stacks. Again, note how lexical address when used both\nthrough `LOAD` and through the implicit default operator do *not*\nremove the referenced values.\n\n    bvm> 17 PUSH hello 3 (0) PUSH (2) LOAD ADD COUNT RETURN\n    [17, \"hello\", 3, 20]\n\nNote how it's legal to store into positions of the stack that don't\nyet have values in them!\n\n    bvm> { PUSH (-1, 1) 2 STORE PUSH (-1, 2) 16 STORE } EXEC ADD COUNT RETURN\n    [\"undef\", 18]\n\nLexical addresses need not be literals: they can be constructed\ndynamically by the `LEXICAL_ADDRESS` operator, which expects to find\ntwo arguments on the top of the stack: the top argument should be a\nnumber which is the *stack index* (as with the shorthands, negative\nvalues are allowed), and the next number should be the *lexical scope\nlevel*. Here, you may use the `UNDEF` opcode to push the `undef` value\nto the stack to indicate the current lexical scope. The following are\nequivalent:\n\n    bvm> 1 { 2 { 3 { (-1, 0) 1 RETURN } 1 RETURN } EXEC } EXEC EXEC\n    [3]\n    bvm> 1 { 2 { 3 { (2, 0) 1 RETURN } 1 RETURN } EXEC } EXEC EXEC\n    [3]\n    bvm> 1 { 2 { 3 { 2 0 LEXICAL_ADDRESS LOAD 1 RETURN } 1 RETURN } EXEC } EXEC EXEC\n    [3]\n\nHowever, note that if you are using the `LEXICAL_ADDRESS` opcode:\n\n1. You **must** provide both operands\n2. The lexical address constructed is then simply placed on the\n  operand stack: it does not at that point go through the implicit\n  default operator as it's not being seen as an opcode. You can then\n  use `LOAD` and `EXEC` to then perform the deferencing and invocation\n  of a code segment, for example.\n\nAgain, the following are equivalent:\n\n    bvm> { PUSH goodbye 1 RETURN } EXEC\n    [\"goodbye\"]\n    bvm> { PUSH goodbye 1 RETURN } (0)\n    [\"goodbye\"]\n    bvm> { PUSH goodbye 1 RETURN } 0 0 LEXICAL_ADDRESS LOAD EXEC\n    [\"goodbye\"]\n    bvm> { PUSH goodbye 1 RETURN } UNDEF -1 LEXICAL_ADDRESS LOAD EXEC\n    [\"goodbye\"]\n\nOnce a lexical address enters the operand stack in non-*deferred\nmode*, it is fixed to the lexical scope determined at that point. This\nmeans these addresses can be used as stable pointers and used to pass\nby reference. This is demonstrated in the following by passing a\nlexical address from one function to another and showing how it still\nloads the value determined relative to the scope in which it is\ncreated:\n\n    bvm> { 17 PUSH (0) 1 RETURN } EXEC { 24 1 TAKE LOAD PUSH (0) LOAD 2 RETURN } EXEC\n    [17, 24]\n\nIf the lexical address was not fixed when it entered the stack, but\nreinterpreted at the point of use then the above would return `[24,\n24]`, not `[17, 24]`.\n\n### Call with Continuation (CALLCC)\n\nThe BVM supports Call-with-Continuation as an opcode. This is a\nrelatively unusual choice, but is extremely useful in practise for\nbuilding more powerful control-flow structures, for example\nco-routines.\n\n`CALLCC` will switch execution to a provided code segment, which does\nnot have any dynamic call chain set up, but is provided with what was\nthe current operand stack on the *take-stack*. Execution of that\noperand stack restores control to the code segment that invoked the\n`CALLCC`, immediately after the `CALLCC` instruction. Thus the old\noperand stack represents the continuation.\n\nThe `CALLCC` opcode expects to find a code segment on the top of the\nstack and it pushes the old operand stack (representing the\ncontinuation) on the top of the old operand stack, which as usual is\naccessible via `TAKE` within the new code segment. There is\ndeliberately no dynamic call chain set up, so when the new code\nsegment returns, control does **not** return to the old segment. For\nexample:\n\n    bvm> 1 3 { 3 TAKE POP ADD COUNT RETURN } CALLCC PUSH hello DEC\n    [4]\n\nNote that none of the instructions to the right of the `CALLCC` get\nevaluated in the above example. Also note that if the `CALLCC` were\nreplaced with an `EXEC` the `3 TAKE` would be illegal as there are\nonly two values that can be taken at that point: it's the `CALLCC`\nthat makes the old operand stack itself available as the uppermost\nelement on the *take-stack*.\n\nBut you can choose to `EXEC` the old operand stack itself and thus\ninvoke the continuation. At that point, control returns to the old\noperand stack and its code segment, but now its own *take-stack* is\nset to the operand stack of the code segment invoked by `CALLCC`\nitself.\n\n    bvm> 3 { 4 1 TAKE EXEC } CALLCC 1 TAKE ADD COUNT RETURN\n    [7]\n\nThe `CALLCC` invokes the preceding code segment. That segment pushes\n`4` to its stack, followed by the old (and suspended or interrupted)\noperand stack, which it then invokes. This returns control to after\nthe `CALLCC`. In the outer (root) code segment, we can now do the `1\nTAKE` which pulls through the `4` which we pushed earlier to the\noperand stack of the inner code segment, we then continue and do the\n`ADD` as normal.\n\nNote that when you invoke a stack, the dynamic call chain is set so\nthat control returns after the stack's code segment completes.\n\n    bvm> 3 { 4 1 TAKE EXEC 2 ADD COUNT RETURN } CALLCC 1 TAKE ADD COUNT RETURN\n    [9]\n\nI.e. the right-most `RETURN` actually passes control back to the inner\ncode segment immediately after the `EXEC`, along with the `7` which\nthen appears on the operand stack of the inner code segment, to which\nwe then add `2`.\n\nEven more exciting is that you can construct loops this way. (`LOG`\ntakes the top value off the stack and prints it out on the console.)\n\n    bvm> { 1 TAKE DUPLICATE EXEC } CALLCC PUSH \"Hello World\" LOG 1 TAKE DUPLICATE EXEC\n    \"Hello World\"\n    \"Hello World\"\n    \"Hello World\"\n    ...\n\nBy making use of the implicit default operator and the fact that\nlexical addresses don't remove values from the stack, we can shorten\nthis to:\n\n    bvm> { 1 TAKE (0) } CALLCC PUSH \"Hello World\" LOG 1 TAKE (0)\n    \"Hello World\"\n    \"Hello World\"\n    \"Hello World\"\n    ...\n\nHere, in the inner code segment, we take the old operand stack and\nduplicate it, which will ensure that when control returns to the outer\ncode segment, the outer code segment can then take *itself*, which it\nthen duplicates (thus maintaining this invariant) before invoking\nitself and thus infinitely looping.\n\n### Errors\n\nAs discussed above, for user errors, it is expected that the\ndictionary stack can be used to set up the relevant error-handling\nfunctions for a `try-catch` block. For errors which occur due to\nmistakes in the code the BVM is running, the same mechanism is used,\nbut with the addition of an implicit suspension of the errored operand\nstack via `CALLCC`.\n\nFor example, if you try to add together a number and a string, an\n*invalid operand* error will be raised. This causes nothing more than\na search through the dictionary stack with the key `\"ERROR INVALID\nOPERAND\"`, and if a code segment is found, it is invoked.\n\n    bvm> 5 PUSH hello ADD\n    Error: Unhandled error in \"ADD\": ERROR INVALID OPERAND\n    bvm> PUSH \"ERROR INVALID OPERAND\" { PUSH here 1 RETURN } STORE 5 PUSH hello ADD\n    [\"here\"]\n\nSo the usual method of storing a code segment in the dictionary stack\nunder the name of the error will cause that code segment to be invoked\nwhen the error is raised. When the error handler is invoked, the\n*take-stack* will contain (from the top down) the old operand stack,\nthen the opcode name (a string), then the error name itself (a string)\nand then any further details provided by the opcode as to the\nspecifics of the error. In the case of *invalid operand*, the operands\nthemselves (one or more of which will be invalid in some way) are\nsupplied.\n\n    bvm> PUSH \"ERROR INVALID OPERAND\" { TAKE_COUNT TAKE COUNT RETURN } STORE 5 PUSH hello ADD\n    [5,\n     \"hello\",\n     \"ERROR INVALID OPERAND\",\n     \"ADD\",\n     {\"type\": \"stack\", /* rest elided */ }]\n\nNow you are obviously free to take whatever action you wish, but it's\nworth remembering that you can always invoke that old operand stack if\nyou want to, in order to pass control back to the errored code\nsegment, to continue after the faulty opcode. This is exactly the same\nas with `CALLCC`. The *take-stack* is set up in exactly the same way\ntoo.\n\n    bvm> PUSH \"ERROR INVALID OPERAND\" { 14 1 TAKE EXEC } STORE 5 PUSH hello ADD 1 TAKE 6 ADD 1 RETURN\n    [20]\n\n### Assembly Labels\n\nSome opcodes (notably `JUMP` and `JUMP_IF`) expect to find a number on\nthe operand stack which represents the offset within the current code\nsegment to set the instruction pointer to. Code segments are really\njust wrapped arrays, where every token is an individual element within\nthe array. Indices start at 0 and are relative to the code segment. No\nform of `JUMP` allows you to set the instruction pointer to an index\nwithin a different code segment.\n\nThus a simple infinite loop might look like:\n\n    bvm> PUSH \"Hello World\" LOG 0 JUMP\n    \"Hello World\"\n    \"Hello World\"\n    \"Hello World\"\n    ...\n\nAnd to demonstrate that indices are local to the current code segment:\n\n    bvm> 5 7 ADD LOG { PUSH \"Hello World\" LOG 0 JUMP } EXEC\n    12\n    \"Hello World\"\n    \"Hello World\"\n    \"Hello World\"\n    ...\n\n> It's important to remember (if slightly obvious when you think about\n> it) that these indices are of the *code segment* and have nothing to\n> do with the operand stack. Also remember that a code segment\n> contains the raw opcodes of any nested code segments.\n\nThe object file JSON always requires these indices to be numbers, but\nthe assembly format supports labels which makes using opcodes such as\n`JUMP` much easier and more robust. There are two forms: `>foo<`\ndeclares the location or target of the label `foo`. This declaration\nis not an opcode and has no *width* itself: it simply marks `foo` as\nbeing the index within the code segment of the opcode immediately\nfollowing the declaration. `<foo>` is a use of the label: it is\nreplaced with the index. Note that labels can be used before they're\ndeclared, and they are scoped to code segments (thus the same label\nname in different code segments is perfectly legal).\n\nThe following pairs of examples demonstrate the translation the\nassembler performs:\n\n    bvm> >here< PUSH \"Hello World\" LOG <here> JUMP\n    \"Hello World\"\n    \"Hello World\"\n    \"Hello World\"\n    ...\n    bvm> PUSH \"Hello World\" LOG 0 JUMP\n    \"Hello World\"\n    \"Hello World\"\n    \"Hello World\"\n    ...\n\n    bvm> <a> JUMP >b< 6 <c> JUMP >c< ADD COUNT RETURN >a< 4 <b> JUMP\n    [10]\n    bvm> 8 JUMP 6 5 JUMP ADD COUNT RETURN 4 2 JUMP\n    [10]\n\n    bvm> { 17 <a> JUMP >b< COUNT RETURN >a< 62 <b> JUMP } EXEC { <a> JUMP >b< ADD COUNT RETURN >a< 2 TAKE <b> JUMP } EXEC\n    [79]\n    bvm> { 17 5 JUMP COUNT RETURN 62 3 JUMP } EXEC { 5 JUMP ADD COUNT RETURN 2 TAKE 2 JUMP } EXEC\n    [79]\n\n\n# BVM Opcode Reference\n\nThroughout the following, the marker `]` is used to indicate the top\nof the stack, and `[` indicates the bottom. If neither are given, the\nstate of the stack is not of any significance. If only `]` is given\nthen only the contents at the top of the stack are significant and the\nstack can otherwise contain any other elements further down.\n\n## Operand Stack Manipulation\n\n* `PUSH`  \n  *Before*:  \n  *After*: `a]`  \n  *where* `a` is the literal element in the code segment immediately\n   following the `PUSH`.  \n  *Errors*: Will error if `PUSH` is the last opcode in a code segment.  \n  > Explicitly pushes an item onto the stack.\n\n* `POP`  \n  *Before*: `a]`  \n  *After*: `]`  \n  *Errors*: Will error if there are no items on the operand stack.  \n  > Removes and discards the top item from the current operand stack.\n\n* `EXCHANGE`  \n  *Before*: `b, a]`  \n  *After*: `a, b]`  \n  *Errors*: Will error if there are fewer than two items on the\n   operand stack.  \n  > Swaps the order of the top two items on the current operand stack.\n\n* `COUNT`  \n  *Before*: <code>[a<sub>0</sub>, ..., a<sub>n-1</sub>]</code>  \n  *After*: <code>[a<sub>0</sub>, ..., a<sub>n-1</sub>, n]</code>  \n  *Errors*: None.  \n  > Pushes onto the current operand stack an integer being the\n  > number of items (or height) of the current operand stack\n  > immediately prior to the evaluation of the `COUNT` opcode.\n\n* `CLEAR`  \n  *Before*:  \n  *After*: `[]`  \n  *Errors*: None.  \n  > Removes all items from the current operand stack.\n\n* `DUPLICATE`  \n  *Before*: `a]`  \n  *After*: `a, a]`  \n  *Errors*: Will error if there are no items on the operand stack.  \n  > Duplicates the item on the top of the current operand stack. If\n  > the item found is a reference type (i.e. an array (including\n  > strings), dictionary, code segment or stack) then it is the\n  > pointer to that item that is duplicated, not the item itself. This\n  > is the same as `1 COPY`.\n\n* `INDEX`  \n  *Before*: <code>[a<sub>0</sub>, ..., a<sub>i</sub>, ..., a<sub>n-1</sub>, i]</code>  \n  *After*: <code>[a<sub>0</sub>, ..., a<sub>i</sub>, ..., a<sub>n-1</sub>, a<sub>i</sub>]</code>  \n  *where* `i` is a non-negative integer and i < n.  \n  *Errors*: Will error if `i` is not a non-negative integer, or if\n   `i` is greater than or equal to the number of items on the\n   current operand stack.  \n  > Pushes onto the current operand stack a duplicate of the `i`th\n  > element of the stack, which is 0-indexed, with the first and\n  > bottom element of the stack being item 0. As with `DUPLICATE`,\n  > reference types are shared, not cloned themselves.\n\n* `COPY`  \n  *Before*: <code>a<sub>0</sub>, a<sub>1</sub>, ..., a<sub>n - 1</sub>, n]</code>  \n  *After*: <code>a<sub>0</sub>, a<sub>1</sub>, ..., a<sub>n - 1</sub>, a<sub>0</sub>, a<sub>1</sub>, ..., a<sub>n - 1</sub>]</code>  \n  *where* `n` is a non-negative integer less than the height of the\n   current operand stack.\n  *Errors*: Will error if there are fewer than `n + 1` items on the\n   current operand stack, or if `n` is not a non-negative integer.\n  > Duplicates the top `n` items of the current operand stack. As\n  > with `DUPLICATE`, reference types are shared, not cloned\n  > themselves. `1 COPY` is the same as `DUPLICATE`.\n\n* `ROLL`  \n  *Before*: <code>a<sub>n-1</sub>, ..., a<sub>0</sub>, n, j]</code>  \n  *After*: <code>a<sub>(j-1) mod n</sub>, ..., a<sub>0</sub>, a<sub>n-1</sub>, ..., a<sub>j mod n</sub>]</code>  \n  *where* `n` is a non-negative integer, and `j` is an integer.  \n  *Errors*: Will error if there are fewer than `n + 2` items on the\n   current operand stack, or if `n` is not a non-negative integer,\n   or if `j` is not an integer.  \n  > After removing the `n` and `j` parameters from the current\n  > operand stack, rolls (or rotates or circular-shifts) the top `n`\n  > items on the current operand stack by `j` steps. Positive `j`\n  > indicates *upwards* motion (i.e. items are popped off the top of\n  > the stack and placed further down, so items below move up),\n  > whilst negative `j` indicates *downwards* motion (i.e. items\n  > from lower down are removed and pushed onto the top of the\n  > stack, so items at the top of the stack move down).\n\n* `CLONE`  \n  *Before*: `a]`  \n  *After*: `a, a]`  \n  *Errors*: Will error if no items on the current operand stack.  \n  > Clones the item on the top of the stack. If the item is a\n  > reference type (i.e. an array (including strings), dictionary,\n  > code segment or stack), the value itself is cloned, thus the\n  > subsequent two pointers will point at distinct values, containing\n  > the same values. This is in contrast to `DUPLICATE` which will\n  > result in two pointers pointing at the same value. If the value is\n  > not a reference type, then there is no difference between `CLONE`\n  > and `DUPLICATE`. Note that in the case of a reference value, the\n  > cloning is shallow.\n\n* `UNDEF`  \n  *Before*:  \n  *After*:  `undef]`  \n  *Errors*: None.  \n  > Pushes the singleton value `undef`, which represents bottom, and\n  > is distinct from `false`, onto the current operand stack.\n\n## Addressing\n\n* A lexical address  \n  *Before*:  \n  *After*: various  \n  *Errors*: Will error if the lexical address is invalid: if\n   *lexical scope level* is greater than the *lexical scope level*\n   of the current function or is less than 0 or is not an integer;\n   or if the *stack index* is not a non-negative index.  \n  > For further details, see the [section on lexical\n  > addresses](#lexical-addresses). A lexical address when seen as an\n  > opcode will be processed by the **implicit default operator**. If\n  > the value pointed to by the lexical address is a code segment then\n  > that segment will be invoked. Otherwise, the value pointed to by\n  > the lexical address will be pushed onto the current operand\n  > stack. Note that whilst the assembly format for lexical addresses\n  > is `(A, B)`, for the JSON object format, lexical addresses are\n  > `[A, B]`.\n\n* Any string that's not recognised as an opcode  \n  *Before*:  \n  *After*: various  \n  *Errors*: None.  \n  > The string is used as a key to search through the dictionary\n  > stack. If first value found is a code segment, that code segment\n  > is invoked. If the first value found is not a code segment, the\n  > value is pushed onto the current operand stack. If the key is\n  > not present in any of the dictionaries in the dictionary stack,\n  > then the `undef` value is pushed onto the current operand\n  > stack. See the [section on the dictionary\n  > stack](#the-dictionary-stack) for a fuller discussion.\n\n* `LEXICAL_ADDRESS`  \n  *Before*: `a, b]`  \n  *After*: `c]`  \n  *where* `a` is either the `undef` value or an interger, and `b` is\n   an integer, and if `a` is a non-negative integer then it is not\n   greater than the *lexical scope level* of the current code segment,\n   and `c` is the lexical address formed by `a` and `b` and fixed to\n   the operand stack indicated by `a`.  \n  *Errors*: Will error if `a` or `b` do not meet the requirements\n   set out above.  \n  > Dynamically creates a new lexical address and pushes it onto the\n  > current operand stack. See the [section on lexical\n  > addresses](#lexical-addresses) for further details.\n\n* `LOAD`  \n  *Before*: `a]`  \n  *After*: `v]`  \n  *where* `a` is a string or a lexical address. If `a` is a string\n   which is recognised as the name of an opcode, then the\n   functionality represented by the opcode is pushed onto the current\n   operand stack. Otherwise, the dictionary stack is searched by using\n   `a` as a key. If a value is found then it is pushed onto the\n   current operand stack. If no value is found from the dictionary\n   stack, the `undef` value is pushed onto the current operand\n   stack. If `a` is a lexical address, the value pointed to by `a` is\n   pushed onto the current operand stack.  \n  *Errors*: Will error if `a` is not a string and `a` is not a lexical\n   address, or if there are no items on the current operand stack.  \n  > Loads a value pointed to by some sort of reference - either a\n  > string keying into firstly the set of known opcodes and secondly\n  > the dictionary stack, or a lexical address. Unlike the **implicit\n  > default operator**, if the value found is a code segment, it is\n  > not executed. Note that the priority of looking up via the set of\n  > known opcodes first and then the dictionary stack matches exactly\n  > the behaviour of the **implicit default operator**.\n\n* `STORE`  \n  *Before*: `a, v]`  \n  *After*: `]`  \n  *where* `a` is a string or a lexical address. If `a` is a string\n   then the value `v` is stored in the dictionary at the top of the\n   dictionary stack under a key of `a`. If an existing value is held\n   in that dictionary under the same key, it is overwritten and\n   lost. If `a` is a lexical address then the value `v` is stored at\n   the location indicated by `a` and any existing value at that\n   location is lost. Note that just like with `ARRAY_STORE`, it is\n   perfectly legal to use a lexical address beyond the length of the\n   indicate lexical scope's operand stack.  \n  *Errors*: Will error if `a` is not a string and `a` is not a lexical\n   address, or if there are fewer than two items on the current\n   operand stack.  \n  > The compliment to `LOAD`, takes a value from the operand stack\n  > and stores that value at the location indicated.\n\n## Mark\n\n> Marks are placed on the stack by various other opcodes, but\n> sometimes there is need to explicitly use them. It's also useful to\n> understand that some other opcodes are little more than a set\n> sequence of opcodes which make use of marks.\n\n* `MARK`  \n  *Before*:  \n  *After*:  `mark]`  \n  *Errors*: None.\n  > Pushes a mark onto the stack.\n\n* `COUNT_TO_MARK`  \n  *Before*: <code>mark, a<sub>0</sub>, ..., a<sub>n-1</sub>]</code>  \n  *After*: <code>mark, a<sub>0</sub>, ..., a<sub>n-1</sub>, n]</code>  \n  *Errors*: Will error if no mark is found in the current operand\n   stack.  \n  > Pushes to the stack an integer representing the number of items\n  > between the uppermost mark on the stack and the top of the\n  > stack, prior to this opcode being invoked.\n\n* `CLEAR_TO_MARK`  \n  *Before*: `mark, ...]`  \n  *After*: `]`  \n  *Errors*: Will error if no mark is found in the current operand\n   stack.  \n  > Removes from the current operand stack all items from the\n  > uppermost mark on the stack to the top of the stack, including\n  > the mark itself.\n\n## Arrays\n\nArrays in the BVM are mutable collections mapping non-negative integer\nindices to values (which are not constrained in any way). Only\nreferences to arrays may enter the operand stack, and arrays are not\nfunctional: they are mutated in place. A string is an array of\ncharacters, and is mutable just like a normal array.\n\n* `ARRAY_START` *(equivalent to `[` in assembly)*  \n  *Before*:  \n  *After*:  `mark]`  \n  *Errors*: None.  \n  > A synonym of `MARK`. Exists to balance `ARRAY_END` and make\n  > intent clear. Note that `ARRAY_START` does not cause *deferred\n  > mode* to be entered (unlike `SEG_START`).\n\n* `ARRAY_END` *(equivalent to `]` in assembly)*  \n  *Before*: <code>mark, a<sub>0</sub>, ..., a<sub>n-1</sub>]</code>  \n  *After*: `ary]`  \n  *where* `ary` is a reference to a fresh array of length `n`\n   containing all the items on the current operand stack above the\n   uppermost mark and up to the top of the top of the\n   stack. <code>a<sub>0</sub></code> is the item in index `0` of the\n   array and <code>a<sub>n-1</sub></code> is the item in index `n-1`\n   of the array.  \n  *Errors*: Will error if no mark is found on the current operand\n   stack.  \n  > Creates an array from the items above the uppermost mark on the\n  > current operand stack. The new array is placed on the stack and\n  > all items from (and including) the uppermost mark and the top of\n  > the stack are removed. Arrays are not homogeneous: you may store\n  > any mix of values and types in an array. Note that due to the\n  > significance of mark in this opcode, you cannot use a literal\n  > array to create an array which contains mark as a value.\n  >\n  > Note that the assembly parser expects pairs of `[` and `]`, and\n  > similarly `ARRAY_START` and `ARRAY_END`. Occasionally there is\n  > reason to want a lone `ARRAY_END`, for example due to use of\n  > `ARRAY_EXPAND` and then wanting to repack the array. You might\n  > expect to be able to write:  \n  >\n  >        MARK [ 1 2 3 ] ARRAY_EXPAND ] COUNT RETURN\n  >\n  > This is currently not accepted by the assembly parser and so this\n  > is one reason why you may wish to use the JSON object format which\n  > does not have these restrictions. There is however a work around:\n  > `PUSH` essentially escapes whatever follows it, so by using `PUSH`\n  > you can make this work:\n  >\n  >        MARK [ 1 2 3 ] ARRAY_EXPAND PUSH ] LOAD EXEC COUNT RETURN\n  >\n  > It's not very pretty, but it does work. Use the JSON object format\n  > to avoid this.\n\n* `ARRAY_EXPAND`  \n  *Before*: `ary]`  \n  *After*: <code>a<sub>0</sub>, ..., a<sub>n-1</sub>]</code>  \n  *where* `ary` is a reference to an array of length `n` which\n   contains the item <code>a<sub>0</sub></code> in index `0` through\n   to item <code>a<sub>n-1</sub></code> in index `n-1`.  \n  *Errors*: Will error if the uppermost item on the current operand\n   stack is not an array reference.  \n  > Removes the array reference at the top of the current operand\n  > stack and expands to the contents of the array. Note that no\n  > mark is added to the stack.\n\n* `ARRAY_NEW`  \n  *Before*:  \n  *After*: `ary]`  \n  *where* `ary` is a reference to a fresh empty array.  \n  *Errors*: None.  \n  > Creates a new empty array and pushes a reference to it onto the\n  > current operand stack.\n\n* `ARRAY_LOAD`  \n  *Before*: `ary, idx]`  \n  *After*: `ary, v]`  \n  *where* `ary` is a reference to an array, `idx` is a non-negative\n   integer, and `v` is the value in the array at index `idx`, or the\n   `undef` value if `idx` is not less than the length of the array.  \n  *Errors*: Will error if `ary` is not an array reference or if\n   `idx` is not a non-negative integer, or if there are fewer than\n   two items on the current operand stack.  \n  > Indexes the supplied array at the supplied index. Note that for\n  > convenience, the array reference itself is left on the stack\n  > below the value found. For consistency with `DICT_LOAD`,\n  > `ARRAY_LOAD` returns the `undef` value rather than erroring if\n  > the supplied index is not less than the length of the array.\n\n* `ARRAY_STORE`  \n  *Before*: `ary, idx, v]`  \n  *After*: `ary]`  \n  *where* `ary` is a reference to an array, `idx` is a non-negative\n   integer, and `v` is the value to be stored in the array `ary` at\n   index `idx`.  \n  *Errors*: Will error if `ary` is not an array reference or if\n   `idx` is not a non-negative integer, or if there are fewer than\n   three items on the current operand stack.  \n  > Stores the supplied value into the supplied array at the\n  > supplied index. Note that for convenience, the array reference\n  > itself is left on the stack. It is legal for the supplied index\n  > to be greater than current length of the array. If this is the\n  > case, the length of the array will be extended and any indices\n  > between the previous length and the supplied index will contain\n  > the `undef` value. In this way, arrays are of dynamic length. If\n  > there is already a value stored in the array at the supplied\n  > index, that value is overwritten and lost.\n\n* `ARRAY_LENGTH`  \n  *Before*: `ary]`  \n  *After*: `ary, n]`  \n  *where* `ary` is a reference to an array of length `n`.  \n  *Errors*: Will error if the top item on the current operand stack\n   is not an array reference or if there are no items on the current\n   operand stack.  \n  > Pushes onto the stack the length of the array, the reference to\n  > which is at the top of the current operand stack. Note that for\n  > convenience, the array reference itself is left on the stack.\n\n* `ARRAY_TRUNCATE`  \n  *Before*: `ary, n]`  \n  *After*: `ary]`  \n  *where* `ary` is a reference to an array, and `n` is a\n   non-negative integer.  \n  *Errors*: Will error if `ary` is not a reference to an array, or\n   if `n` is not a non-negative integer, or if there are fewer than\n   two items on the current operand stack.  \n  > Truncates the array at the supplied array reference to the\n  > length supplied. If the length supplied is less than the current\n  > length, items are lost from the array. If the length supplied is\n  > greater than the current length then the array is extended and\n  > values of the new indices are filled with the `undef`\n  > value. After this opcode, `ARRAY_LENGTH` will always reveal the\n  > length just set by the `ARRAY_TRUNCATE` opcode.\n\n* `ARRAY_PUSH`  \n  *Before*: `ary, v]`  \n  *After*: `ary]`  \n  *where* `ary` is an array and `v` is a value to add to the end of\n   the array.  \n  *Errors*: Will error if `ary` is not an array reference or if there\n   are fewer than 2 items on the current operand stack.  \n  > Adds the value onto the end of the array. The array is modified in\n  > place, and left on the top of the operand stack.\n\n* `ARRAY_POP`  \n  *Before*: `ary]`  \n  *After: `ary, v]`  \n  *where* `ary` is an array and `v` is the value found at the end of\n   the array.  \n  *Errors*: Will error if `ary` is not an array reference or if there\n   are fewer than 2 items on the current operand stack.  \n  > Removes the value at the end of the array from the array and\n  > places both the shortened array and the removed value onto the\n  > current operand stack. The array is modified in place.\n\n* `ARRAY_UNSHIFT`  \n  *Before*: `ary, v]`  \n  *After*: `ary]`  \n  *where* `ary` is an array and `v` is a value to add to the start of\n   the array.  \n  *Errors*: Will error if `ary` is not an array reference or if there\n   are fewer than 2 items on the current operand stack.  \n  > Adds the value onto the start of the array. The array is modified\n  > in place, and left on the top of the operand stack.\n\n* `ARRAY_SHIFT`  \n  *Before*: `ary]`  \n  *After: `ary, v]`  \n  *where* `ary` is an array and `v` is the value found at the start of\n   the array.  \n  *Errors*: Will error if `ary` is not an array reference or if there\n   are fewer than 2 items on the current operand stack.  \n  > Removes the value at the start of the array from the array and\n  > places both the shortened array and the removed value onto the\n  > current operand stack. The array is modified in place.\n\n* `ARRAY_MAP`  \n  *Before*: `ary, s]`  \n  *After*: `ary]`  \n  *where*: `ary` is an array and `s` is something executable: a\n   segment or a stack.  \n  *Errors*: Will error if `ary` is not an array reference or if `s` is\n   not executable, or if there are fewer than two items on the current\n   operand stack.  \n  > Maps `s` over the elements of `ary`. For each element of the\n  > array, the current value is replaced with the result of applying\n  > the current value to `s`. That is, for each element of the array,\n  > `s` is invoked and finds the current value on the take stack. If\n  > `s` returns any values, the top most value it returns is used to\n  > replace the current value. For example:\n  >\n  >        bvm> [ 7 8 9 ] { 1 TAKE INC 1 RETURN } ARRAY_MAP COUNT RETURN\n  >        [[8, 9, 10]]\n\n* `ARRAY_FOLDL`  \n  *Before*: `ary, acc, s]`  \n  *After*: `ary, acc]`  \n  *where*: `ary` is an array, `acc` is any value, and `s` is something\n   executable: a segment or a stack.  \n  *Errors*: Will error if `ary` is not an array reference or if `s` is\n   not executable, or if there are fewer than three items on the\n   current operand stack.  \n  > Folds `s` over the elements of `ary`, starting from the left of\n  > `ary`. For each element of the array, the current value and the\n  > current accumulator (`acc`) are applied to `s`. If `s` returns a\n  > value, that value replaces the value held in `acc`. After all the\n  > elements of the array have been iterated through, the current\n  > value of `acc` is returned, with the array to the current operand\n  > stack. Note that `s` is invoked with the current array element\n  > uppermost, and the accumulator beneath, on the take stack. The\n  > first invocation of `s` is with the array element at index 0. For\n  > example:\n  >\n  >        bvm> [ 7 8 9 ] 0 { 2 TAKE (-1) LOG INC ADD 1 RETURN } ARRAY_FOLDL COUNT RETURN\n  >        7\n  >        8\n  >        9\n  >        [[7, 8, 9], 27]\n\n* `ARRAY_FOLDR`  \n  *Before*: `ary, acc, s]`  \n  *After*: `ary, acc]`  \n  *where*: `ary` is an array, `acc` is any value, and `s` is something\n   executable: a segment or a stack.  \n  *Errors*: Will error if `ary` is not an array reference or if `s` is\n   not executable, or if there are fewer than three items on the\n   current operand stack.  \n  > Folds `s` over the elements of `ary`, starting from the right of\n  > `ary`. For each element of the array, the current value and the\n  > current accumulator (`acc`) are applied to `s`. If `s` returns a\n  > value, that value replaces the value held in `acc`. After all the\n  > elements of the array have been iterated through, the current\n  > value of `acc` is returned, with the array to the current operand\n  > stack. Note that `s` is invoked with the current array element\n  > uppermost, and the accumulator beneath, on the take stack. The\n  > first invocation of `s` is with the array element at the higest index of `ary`. For\n  > example:\n  >\n  >        bvm> [ 7 8 9 ] 0 { 2 TAKE (-1) LOG INC ADD 1 RETURN } ARRAY_FOLDR COUNT RETURN\n  >        9\n  >        8\n  >        7\n  >        [[7, 8, 9], 27]\n\n* `ARRAY_EQ`  \n  *Before*: `a, b]`  \n  *After*: `c]`  \n  *where*: `a` and `b` are arrays. `c` is a boolean.  \n  *Errors*: Will error if either `a` or `b` are not arrays, or if\n   there are fewer than two items on the current operand stack.  \n  > Shallow structural equality of arrays. Checks that the arrays have\n  > the same length, and if they do, performs `EQ` on corresponding\n  > elements from the arrays. Will return true if and only if both\n  > arrays have the \"same\" (as defined by `EQ`) elements in the same\n  > order. False otherwise.\n\n* `ARRAY_TO_SEG`  \n  *Before*: `ary]`  \n  *After*: `seg]`  \n  *where* `ary` is a reference to an array and `seg` is a reference\n   to a code segment where the opcodes within the code segment are\n   taken from the array.  \n  *Errors*: Will error if the item at the top of the current operand\n   stack is not an array reference or if there are no items on the\n   current operand stack.  \n  > Converts an array to a segment. Note that the segment shares the\n  > array itself, so if you retain a reference to the array before\n  > invoking `ARRAY_TO_SEG` then the array used to store the code\n  > segment's opcodes will be the same as the array. No checking is\n  > done that the contents of the array represent valid opcodes, so\n  > any errors due to this won't surface until invocation of the\n  > segment. However, remember that the **implicit default\n  > operator** will, if nothing else, push the current unrecognised\n  > opcode onto the current operand stack if it's not a string,\n  > lexical address or code segment. This means that this opcode\n  > allows opcodes that have no string representation to be used\n  > directly, such as array and dictionary references.\n  >\n  > It is important to very carefully consider what will happen to\n  > lexical addresses within the array when using this opcode. Given\n  > the array will have been constructed on the operand stack, all\n  > lexical addresses that entered the operand stack will be fixed\n  > relative to the *current* code segment, not the code segment to\n  > be constructed. For example:\n  >\n  >        bvm> 5 [ 17 PUSH (0) 1 PUSH RETURN ] ARRAY_TO_SEG EXEC\n  >        [5]\n  >        bvm> 5 [ 17 PUSH (0,0) 1 PUSH RETURN ] ARRAY_TO_SEG EXEC\n  >        [5]\n  >        bvm> 5 [ 17 PUSH (1,0) 1 PUSH RETURN ] ARRAY_TO_SEG EXEC\n  >        Error: Unhandled error in \"PUSH\": ERROR INVALID OPERAND\n  >\n  > I.e., the *lexical scope level* of 1 does not exist until\n  > `ARRAY_TO_SEG` is invoked, and that is too late for a literal\n  > lexical address of `(1,0)`. This is why the first two examples\n  > both yield `5`: the current *lexical scope level* implied by the\n  > shorthand `(0)` is indeed still `0`. Thus in this situation, you\n  > must the opcode `LEXICAL_ADDRESS` to dynamically construct\n  > lexical addresses when the segment is finally invoked. This way,\n  > the lexical addresses will be fixed relative to the new code\n  > segment when it is invoked.\n  >\n  >        bvm> 5 [ 17 1 0 PUSH LEXICAL_ADDRESS PUSH LOAD 1 PUSH RETURN ] ARRAY_TO_SEG EXEC\n  >        [17]\n\n\n## Dictionaries\n\nDictionaries in the BVM are mutable collections mapping keys (which\nmust be strings) to values (which are not constrained in any\nway). Only references to dictionaries may enter the operand stack, and\ndictionaries are not functional: they are mutated in place. Note that\ncomparison of keys is done on a string basis rather than on an array\nbasis, and also note that the dictionary will take and provide copies\nof keys so to ensure that you cannot share a string/character-array\nboth on the operand stack and being used as a key by a dictionary.\n\n* `DICT_START` *(equivalent to `<` in assembly)*  \n  *Before*:  \n  *After*:  `mark]`  \n  *Errors*: None.  \n  > A synonym of `MARK`. Exists to balance `DICT_END` and make\n  > intent clear. Note that `DICT_START` does not cause *deferred\n  > mode* to be entered (unlike `SEG_START`).\n\n* `DICT_END` *(equivalent to `>` in assembly)*  \n  *Before*: <code>mark, k<sub>0</sub>, v<sub>0</sub>, ..., k<sub>n-1</sub>, v<sub>n-1</sub>]</code>  \n  *After*: `dict]`  \n  *where* `dict` is a reference to a fresh dictionary containing\n   `n` key-value pairs of no distinct order, where\n   <code>k<sub>i</sub></code> is the key of value\n   <code>v<sub>i</sub></code> for all non-negative integers `i` less\n   than `n`.  \n  *Errors*: Will error if no mark is found on the current operand\n   stack or if there are an odd number of items between the\n   uppermost mark on the current operand stack and the top of the\n   stack, or if any of the keys are not strings.\n  > Creates a dictionary from the items above the uppermost mark on\n  > the current operand stack. The new dictionary is placed on the\n  > stack and all items from (and including) the uppermost mark and\n  > the top of the stack are removed. Dictionaries are not\n  > homogeneous: you may store any mix of values and types as values\n  > in a dictionary. All keys must be strings. Note that due to the\n  > significance of mark in this opcode, you cannot use a literal\n  > dictionary to create a dictionary which contains mark as a value\n  > (or key).\n  >\n  > Note that the assembly parser expects pairs of `<` and `>`, and\n  > similarly `DICT_START` and `DICT_END`. Occasionally there is\n  > reason to want a lone `DICT_END`, for example due to use of\n  > `DICT_EXPAND` and then wanting to repack the dictionary. You might\n  > expect to be able to write:  \n  >\n  >        MARK < PUSH \"a\" 1 PUSH \"b\" 2 > DICT_EXPAND > COUNT RETURN\n  >\n  > This is currently not accepted by the assembly parser and so this\n  > is one reason why you may wish to use the JSON object format which\n  > does not have these restrictions. There is however a work around:\n  > `PUSH` essentially escapes whatever follows it, so by using `PUSH`\n  > you can make this work:\n  >\n  >        MARK < PUSH \"a\" 1 PUSH \"b\" 2 > DICT_EXPAND PUSH > LOAD EXEC COUNT RETURN\n  >\n  > It's not very pretty, but it does work. Use the JSON object format\n  > to avoid this.\n\n* `DICT_NEW`\n  *Before*:  \n  *After*: `dict]`  \n  *where* `dict` is a reference to a fresh empty dictionary.  \n  *Errors*: None.  \n  > Creates a new empty dictionary and pushes a reference to it onto\n  > the current operand stack.\n\n* `DICT_EXPAND`  \n  *Before*: `dict]`  \n  *After*: <code>k<sub>0</sub>, v<sub>0</sub>, ..., k<sub>n-1</sub>, v<sub>n-1</sub>]</code>  \n  *where* `dict` is a reference to a dictionary containing `n`\n   key-value pairs.\n  *Errors*: Will error if the uppermost item on the current operand\n   stack is not a dictionary reference.  \n  > Removes the dictionary reference at the top of the current\n  > operand stack and expands to the contents of the\n  > dictionary. Note that no mark is added to the stack.\n\n* `DICT_CONTAINS`  \n  *Before*: `dict, key]`  \n  *After*: `dict, boolean]`  \n  *where* `dict` is a reference to a dictionary, `key` is a string\n   which is the key to test the dictionary with, `boolean` is a\n   boolean value representing whether or not the dictionary contains\n   a key-value pair with the key supplied.  \n  *Errors*: Will error if `dict` is not a dictionary reference or if\n   `key` is not a string, or if fewer than two items on the current\n   operand stack.  \n  > Tests whether the supplied dictionary has a key-value pair for\n  > the key provided. Note that if you store the `undef` value in a\n  > dictionary, the dictionary still has the corresponding key:\n  > storing a value of `undef` is **not** equivalent to explicitly\n  > removing a key-value pair from the dictionary. Note for\n  > convenience, the dictionary reference is left on the stack.\n\n* `DICT_REMOVE`  \n  *Before*: `dict, key]`  \n  *After*: `dict]`  \n  *where* `dict` is a reference to a dictionary and `key` is a\n   string which is the key to remove from the dictionary.  \n  *Errors*: Will error if `dict` is not a reference to a dictionary,\n   or if `key` is not a string, or if there are fewer than two items\n   on the current operand stack. It is not an error to try to remove\n   a key from the dictionary which does not exist in dictionary\n   (i.e. `DICT_REMOVE` is idempotent).  \n  > Removes the supplied key from the supplied dictionary. Leaves\n  > the dictionary reference on the stack. Does not indicate whether\n  > or not the dictionary contained the key: use `DICT_CONTAINS` if\n  > you need to know.\n\n* `DICT_LOAD`  \n  *Before*: `dict, key]`  \n  *After*: `dict, value]`  \n  *where* `dict` is a reference to a dictionary, `key` is a string\n   by which to index the dictionary, and `value` is the value\n   consequently found or the `undef` value if the key is not found\n   in the dictionary.  \n  *Errors*: Will error if `dict` is not a dictionary reference or if\n   `key` is not a string, or if there are fewer than two items on\n   the current operand stack.  \n  > Indexes the supplied dictionary by the supplied key, and returns\n  > the value found. If the dictionary does not contain the supplied\n  > key, returns `undef` as the value. Note that because it is legal\n  > to store `undef` in a dictionary as a value, a result of `undef`\n  > does not indicate whether or not the dictionary contains the\n  > supplied key. Use `DICT_CONTAINS` if you wish to find out.\n\n* `DICT_STORE`  \n  *Before*: `dict, key, v]`  \n  *After*: `dict]`  \n  *where* `dict` is a reference to a dictionary, `key` is a string\n   representing a key, and `v` is the value to store in the\n   dictionary under the key `key`.  \n  *Errors*: Will error if `dict` is not a dictionary reference, or\n   if `key` is not a string, or if there are fewer than 3 items on\n   the current operand stack.  \n  > Stores the supplied key-value pair in the supplied\n  > dictionary. Leaves the dictionary on the stack. If the\n  > dictionary already contained the supplied key, the corresponding\n  > value is overwritten and lost.\n\n* `DICT_KEYS`  \n  *Before*: `dict]`  \n  *After*: `dict, ary]`  \n  *where* `dict` is a reference to a dictionary, `ary` is a reference\n   to an array, and the contents of the array are copies of the\n   strings which are all the keys in `dict`.  \n  *Errors*: Will error if `dict` is not a dictionary reference or if\n   there are no items on the current operand stack.  \n  > Creates and returns a fresh array containing all the keys found\n  > within the dictionary. The dictionary reference is left on the\n  > stack.\n\n* `DICT_MAP`  \n  *Before*: `dict, s]`  \n  *After*: `dict]`  \n  *where*: `dict` is a dictionary and `s` is something executable: a\n   segment or a stack.  \n  *Errors*: Will error if `dict` is not a dictionary reference or if\n   `s` is not executable, or if there are fewer than two items on the\n   current operand stack.  \n  > Maps `s` over the key-value pairs of `dict`. For each key-value\n  > pair in the dictionary, the current value is replaced with the\n  > result of applying the key and current value to `s`. That is, for\n  > each element of the dictionary, `s` is invoked and finds the\n  > current value uppermost on the take stack, with the key beneath\n  > it. If `s` returns any values, the top most value it returns is\n  > used to replace the current value. For example:\n  >\n  >        bvm> < PUSH a 7 PUSH b 8 PUSH c 9 > { 2 TAKE EXCHANGE LOG INC 1 RETURN } DICT_MAP COUNT RETURN\n  >        a\n  >        b\n  >        c\n  >        [{\"a\": 8, \"b\": 9, \"c\": 10}]\n\n* `DICT_FOLD`  \n  *Before*: `dict, acc, s]`  \n  *After*: `dict, acc]`  \n  *where*: `dict` is a dictionary, `acc` is any value, and `s` is\n   something executable: a segment or a stack.  \n  *Errors*: Will error if `dict` is not a dictionary reference or if\n   `s` is not executable, or if there are fewer than three items on\n   the current operand stack.  \n  > Folds `s` over the key-value pairs of `dict`. For each key-value\n  > pair in the dictionary, the key, the current value, and the\n  > current accumulator (`acc`) are applied to `s`. If `s` returns a\n  > value, that value replaces the value held in `acc`. After all the\n  > key-value pairs of the dictionary have been iterated through, the\n  > current value of `acc` is returned, with the dictionary to the\n  > current operand stack. Note that `s` is invoked with the current\n  > key-value pair value uppermost, current key beneath it, and the\n  > accumulator beneath that, on the take stack.  For example:\n  >\n  >        bvm> < PUSH a 7 PUSH b 8 PUSH c 9 > 0 { 3 TAKE EXCHANGE LOG INC ADD 1 RETURN } DICT_FOLD COUNT RETURN\n  >        a\n  >        b\n  >        c\n  >        [{\"a\": 7, \"b\": 8, \"c\": 9}, 27]\n\n* `DICT_EQ`  \n  *Before*: `a, b]`  \n  *After*: `c]`  \n  *where*: `a` and `b` are dictionaries. `c` is a boolean.  \n  *Errors*: Will error if either `a` or `b` are not dictionaries, or\n   if there are fewer than two items on the current operand stack.  \n  > Shallow structural equality of dictionaries. Checks that the\n  > dictionaries have the same keys, and if they do, performs `EQ` on\n  > corresponding values from the dictionaries. Will return true if\n  > and only if both dictionaries have the \"same\" (as defined by `EQ`)\n  > value for each key. False otherwise.\n\n\n## Code Segments\n\n`SEG_START` and `SEG_END` are the only opcodes that have any effect\nwhen in *deferred mode* in that they always adjust the *deferred mode*\ncounter. This is the reason why the two possible outcomes are\nexplicitly shown in this section. All other opcodes have no action\nwhen in *deferred mode*, other than to be pushed onto the operand\nstack (and in all other sections, this is not shown as a possible\noutcome. Indeed it is not necessary for implementations to implement\n*deferred mode* at all: all that is necessary is to detect balanced\npairs of `SEG_START` and `SEG_END` (taking care to detect and account\nfor the fact that `PUSH` essentially *escapes* whatever follows it)\nand to construct a segment from what lies between). See the [section\non code segments](#literal-code-segments) for more details. When the\nBVM is first started, the *deferred mode* counter is set to zero.\n\n* `SEG_START` *(equivalent to `{` in assembly)*  \n  *Before*:  \n  *After*: `mark]` or `SEG_START]`  \n  *Errors*: None.  \n  > Increments the *deferred mode* counter. If the *deferred mode*\n  > counter is now `1`, we have just entered *deferred mode*, so we\n  > push a mark onto the stack.  If the *deferred mode* counter is now\n  > greater than `1`, we were already in *deferred mode* so simply\n  > push the opcode `SEG_START` onto operand stack, as usual.\n\n* `SEG_END` *(equivalent to `}` in assembly)*  \n  *Before*: <code>mark, v<sub>0</sub>, ..., v<sub>n-1</sub>]</code>  \n  *After*: `seg]` *or* <code>mark, v<sub>0</sub>, ..., v<sub>n-1</sub>, SEG_END]</code>  \n  *where* `seg` is a reference to a fresh code segment containing in\n   order <code>v<sub>0</sub></code> to <code>v<sub>n-1</sub></code>\n   found above the uppermost mark on the current operand stack.  \n  *Errors*: Will error if no mark is found on the current operand\n   stack.  \n  > Decrements the *deferred mode* counter. If the *deferred mode*\n  > counter is now 0, then we have just left *deferred mode*, so we\n  > create a fresh code segment containing the items above the\n  > uppermost mark on the current operand stack, and push that code\n  > segment onto the stack. If the *deferred mode* counter is still\n  > greater than 0, then we remain in *deferred mode*, and so simply\n  > push the opcode `SEG_END` onto the operand stack, as\n  > usual.\n\n* `SEG_TO_ARRAY`  \n  *Before*: `seg]`  \n  *After*: `ary]`  \n  *where* `seg` is a reference to a code segment, and `ary` is a\n  reference to the array holding the opcodes within the code segment.  \n  *Errors*: Will error if the item at the top of the current operand\n   stack is not a code segment reference or if there are no items on\n   the current operand stack.  \n  > Converts a segment to an array. This is the mirror of\n  > `ARRAY_TO_SEG`, and just like that opcode, the array is shared\n  > with the code segment. Note that you may not use this on a\n  > built-in opcode. Thus the following example is illegal:\n  >\n  >        bvm> PUSH ADD LOAD SEG_TO_ARRAY\n  >        Error: Unhandled error in \"SEG_TO_ARRAY\": ERROR INVALID OPERAND\n\n* `EXEC`  \n  *Before*: `s]`  \n  *After*:  \n  *where* `s` is a reference to either a code segment or a stack.  \n  *Errors*: Will error if the item at the top of the current operand\n   stack is not a code segment reference or a stack, or if there are\n   no items on the current operand stack.  \n  > Explicitly invokes the item at the top of the current operand\n  > stack. In all non-erroring cases, control will return to the next\n  > opcode after the current `EXEC` once the invoked item\n  > completes. If the item is a code segment then it is invoked\n  > normally with a fresh empty operand stack, and with its\n  > *take-stack* set to the current operand stack. If the item is a\n  > stack, then the stack is invoked, continuing from immediately\n  > after the `CALLCC` opcode which caused it to be suspended. The\n  > stack's *take-stack* is now set to the current operand stack. The\n  > stack may be invoked multiple times, and each time it will resume\n  > from the same instruction. However the operand stack is maintained\n  > and shared across each invocation, as the following example\n  > demonstrates:\n  >\n  >        bvm> 5 { 1 TAKE DUPLICATE EXEC EXEC COUNT RETURN } CALLCC COUNT LOG POP\n  >        1\n  >        0\n  >        Error: Unhandled error in \"POP\": ERROR NOT ENOUGH OPERANDS\n  >\n  > The first `EXEC` resumes the suspension after the `CALLCC` with\n  > `5` on its operand stack. This causes `COUNT` to push `1`, which\n  > is then removed and displayed by `LOG`. `POP` then removes the\n  > `5`. Control then returns to the inner code segment which then\n  > invokes the second `EXEC`, again resuming the same suspension at\n  > the same point (after the `CALLCC`). But as its operand stack is\n  > maintained, this time there is no `5` on the stack. So the `COUNT`\n  > pushes `0`, which is removed and displayed by `LOG`, and the the\n  > `POP` errors as there is nothing on the operand stack to pop.\n  >\n  > However, if we replace the `DUPLICATE` with a `CLONE` then we are\n  > explicitly cloning the stack and its contents before invoking each\n  > one. This makes the contents of the stacks distinct:\n  >\n  >        bvm> 5 { 1 TAKE CLONE EXEC EXEC COUNT RETURN } CALLCC COUNT LOG POP\n  >        1\n  >        1\n  >        []\n\n* `CALLCC`  \n  *Before*: `s]`  \n  *After*:  \n  *where* `s` is a reference to either a code segment or a stack.  \n  *Errors*: Will error if `s` is not a code segment or a stack, or if\n   there are no items on the current operand stack.  \n  > Suspends the current code segment and its operand stack. Control\n  > is passed to the code segment or stack found at the top of the\n  > current operand stack and no dynamic control chain is created:\n  > when the supplied code segment or stack completes, control does\n  > not automatically return to the current code segment. The current\n  > code segment and its operand stack is suspended as a stack, and\n  > pushed onto its own operand stack, which becomes the *take-stack*\n  > for the supplied code segment or stack which is invoked. The\n  > supplied and invoked code segment or stack may retrieve the newly\n  > suspended stack via `TAKE` as usual, and beyond that can access\n  > the contents of the operand stack of the suspended code\n  > segment. It may resume the suspension, zero or more times, using\n  > `EXEC`. See the above entry for `EXEC` and also the [section on\n  > Call with Continuation](#call-with-continuation-callcc).\n\n* `RETURN`  \n  *Before*: <code>a<sub>0</sub>, a<sub>1</sub>, ..., a<sub>n - 1</sub>, n]</code>  \n  *After*: <code>a<sub>0</sub>, a<sub>1</sub>, ..., a<sub>n - 1</sub>]</code>  \n  *where* the *after* is the operand stack of the caller, and the\n   *before* is the operand stack of the callee.  \n  *Errors*: Will error if `n` is not a non-negative integer or if there\n   are fewer than `n` items on the current operand stack.  \n  > Returns control to the calling segment and explicitly passes a\n  > number of items from the current operand stack to the operand\n  > stack of the calling segment. It is legal for `RETURN` to occur\n  > when the current operand stack is completely empty. In this case,\n  > it is implicitly understood that no items are to be returned to\n  > the calling segment's operand stack.\n\n* `TAKE`  \n  *Before*: `n]`  \n  *After*: <code>a<sub>0</sub>, a<sub>1</sub>, ..., a<sub>n - 1</sub>]</code>  \n  *where* `n` is a non-negative integer, and <code>a<sub>0</sub>,\n   a<sub>1</sub>, ..., a<sub>n - 1</sub></code> are the uppermost `n`\n   items on the current *take-stack*.  \n  *Errors*: Will error if `n` is not a non-negative integer, or if\n   there are no items on the current operand stack, or if `n` is\n   greater than the number of items on the current *take-stack*.  \n  > Moves items from the current *take-stack* to the current operand\n  > stack. This is how code segments are expected to retrieve their\n  > arguments.\n\n* `TAKE_COUNT`  \n  *Before*:  \n  *After*: `n]`  \n  *where* `n` is a non-negative integer representing the number of\n   items in (or height of) the current *take-stack*.  \n  *Errors*: None.  \n  > Pushes to the current operand stack the integer representing the\n  > number of items available on the current *take-stack*. In most\n  > cases, the *take-stack* is the operand stack of your caller. This\n  > opcode is most of use for variadic segments.\n\n## Dictionary Stack\n\nSee the [section on the dictionary stack](#the-dictionary-stack) for a\ndiscussion of its purpose and expected use. When the BVM is started,\nthe dictionary stack contains one dictionary which is empty. You can\nthink of all the opcodes as being items in a dictionary at the very\ntop of the dictionary stack which can not be modified by this API.\n\n* `DICT_STACK_PUSH`  \n  *Before*: `dict]`  \n  *After*: `]`  \n  *where* `dict` is a dictionary reference.  \n  *Errors*: Will error if `dict` is not a dictionary reference or if\n   there are no items on the current operand stack.  \n  > Pushes the supplied dictionary onto the dictionary stack where it\n  > becomes the uppermost item in the dictionary stack. The supplied\n  > dictionary itself is placed on the dictionary stack: no copying or\n  > cloning takes place.\n\n* `DICT_STACK_POP`  \n  *Before*:  \n  *After*: `dict]`  \n  *where* `dict` is a reference to what was the uppermost dictionary\n   on the dictionary stack, or the `undef` value if the dictionary\n   stack is empty.  \n  *Errors*: None.  \n  > Removes the uppermost item from the dictionary stack and pushes it\n  > to the current operand stack. If the dictionary stack is empty,\n  > pushes the `undef` value to the current operand stack.\n\n* `DICT_STACK_WHERE`  \n  *Before*: `key]`  \n  *After*: `dict]`  \n  *where* `key` is a string by which to search the dictionary stack,\n   and `dict` is the first dictionary found containing that key,\n   searching from the uppermost dictionary downwards, or the `undef`\n   value if no dictionary was found containing that key.  \n  *Errors*: Will error if the item on the top of the current operand\n   stack is not a string or if there are no items on the current\n   operand stack.  \n  > Searches through the dictionary stack for the first dictionary\n  > containing the supplied key, and pushes that dictionary onto the\n  > current operand stack. If no such dictionary is found, pushes the\n  > `undef` value.\n\n* `DICT_STACK_REPLACE`  \n  *Before*: `key, v]`  \n  *After*: `]`  \n  *where* `key` is a string and `v` is a value.  \n  *Errors*: Will error if `key` is not a string, or if there are fewer\n   than two items on the current operand stack, or if the dictionary\n   stack is empty.  \n  > Searches the dictionary stack for the first dictionary from the\n  > top downwards containing the supplied key. If such a dictionary is\n  > found, the key and value supplied are stored in the dictionary,\n  > replacing the existing key-value pair. If no dictionary is found\n  > containing the key supplied then the uppermost dictionary in the\n  > dictionary stack is used to store the key-value pair supplied.\n\n* `DICT_STACK_LOAD`  \n  *Before*:  \n  *After*: `ary]`  \n  *where* `ary` is a reference to the array containing all the\n   dictionaries in the dictionary stack, where the dictionary at index\n   `0` in the array represents the bottom of the dictionary stack.  \n  *Errors*: None.  \n  > Pushes onto the current operand stack the dictionary stack. This\n  > is the actual dictionary stack, not a clone or copy. Thus any\n  > modifications to this array affect the dictionary stack too. As\n  > such, if you store non-dictionary values into this array, you can\n  > break the BVM. You have been warned.\n\n* `DICT_STACK_SET`  \n  *Before*: `ary]`  \n  *After*: `]`  \n  *where* `ary` is a reference to an array containing only\n   dictionaries.  \n  *Errors*: Will error if the item at the top of the stack is not an\n   array reference, or if any of the values found within the array are\n   not dictionaries, or if there are no items on the stack.  \n  > Sets the entire dictionary stack to the array at the top of the\n  > current operand stack, where the dictionary in index `0` of the\n  > array is the bottom of the dictionary stack. Note that this sets\n  > the entire dictionary stack to the value provided: the dictionary\n  > stack becomes the array provided and the previous entire\n  > dictionary stack is discarded.\n\n## Control flow\n\nFor both `IF` and `IF_ELSE` note that the invocations these can cause\ncan still be tail calls: the requirement for a tail call is merely\nthat there are no more opcodes to come in the current code\nsegment. This says nothing about the last opcode being an `EXEC`, or\nan unrecognised string to look up in the dictionary stack and maybe\ninvoke, for example. Thus if the last instruction in a segment is an\n`IF_ELSE`, the code segment chosen to invoke will still be invoked as\na tail call, with all that that entails.\n\n* `IF`  \n  *Before*: `s, b]`  \n  *After*: `]`  \n  *where* `s` is a code segment or stack and `b` is a boolean.  \n  *Errors*: Will error if `b` is not a boolean or `s` is not a code\n   segment or stack, or if there are fewer than two items on the\n   current operand stack.  \n  > Removes the top two items from the current operand stack. If the\n  > uppermost item was the `true` boolean value, the code segment (or\n  > stack) beneath it is invoked as per a normal `EXEC`\n  > call. Otherwise, a no-op.\n\n* `IF_ELSE`  \n  *Before*:  `sT, sF, b]`  \n  *After*: `]`  \n  *where* `sT` and `sF` are code segments or stacks and `b` is a\n   boolean.  \n  *Errors*: Will error if `b` is not a boolean, or if either `sT` or\n   `sF` are not code segments or stacks, or if there are fewer than\n   three items on the current operand stack.  \n  > Removes the top three items from the current operand stack. If the\n  > uppermost item was the `true` boolean value then the lowest item\n  > removed (`sT` in the above) is invoked. If the uppermost item was\n  > the `false` boolean value then the upper code segment (`sF` in the\n  > above) is invoked.\n\n* `JUMP`  \n  *Before*: `n]`  \n  *After*: `]`  \n  *where* `n` is a non-negative integer less than the number of\n   opcodes in the current code segment.  \n  *Errors*: Will error if `n` is not a non-negative integer or if it\n   is not less than the number of opcodes in the current segment, or\n   if there are no items on the current operand stack.  \n  > Directly adjusts the current instruction pointer. Note it is not\n  > possible to directly set the instruction pointer to an offset in a\n  > different code segment: you may only move about within the current\n  > code segment. Offsets are relative to the start of each code\n  > segment. Please see also the [section on Assembly\n  > Labels](#assembly-labels) for a robust way to indicate such\n  > offsets in the assembly format.\n\n* `JUMP_IF`  \n  *Before*: `n, b]`  \n  *After*: `]`  \n  *where* `n` is a non-negative integer less than the number of\n   opcodes in the current code segment, and `b` is a boolean.  \n  *Errors*: Will error if `n` is not a non-negative integer or if it\n   is not less than the number of opcodes in the current segment, if\n   `b` is not a boolean value, or if there are fewer than two items on\n   the current operand stack.  \n  > Conditional jump. Directly adjust the instruction pointer as with\n  > `JUMP` if the boolean value found at the top of the current\n  > operand stack is found to be the `true` value. Otherwise, a no-op.\n\n## Comparison\n\n* `EQ`  \n  *Before*: `x, y]`  \n  *After*: `b]`  \n  *where* `x` and `y` are any values, and `b` is a boolean.  \n  *Errors*: Will error if there are fewer than two items on the\n   current operand stack.  \n  > Tests the two items at the top of the current operand stack for\n  > equality. Pushes `true` if the two items are found equal, and\n  > `false` otherwise. For reference values (arrays, dictionaries,\n  > code segments and stacks), equality is pointer equality. Note that\n  > this implies strings are compared for pointer equality. String\n  > equality is covered elsewhere. This reinforces the difference\n  > between the `CLONE` and `DUPLICATE` opcodes for reference\n  > types. For simple types (numbers, booleans, characters, the\n  > singleton values undef and mark), it is the semantic definition of\n  > equality. For lexical addresses, the lexical scope in which the\n  > address was declared must be the same, and the index must be the\n  > same too. I.e. lexical addresses with the same *lexical scope\n  > level* and the same index, but declared in different lexical\n  > scopes are considered distinct. Note that this includes the\n  > youngest scope. Consider carefully the following examples:\n  >\n  >        // Youngest scope is fresh for each segment invocation.\n  >        bvm> { PUSH (0) 1 RETURN } (0) (0) 2 COPY EQ 3 RETURN\n  >        [{\"type\": \"lexical address\", \"lsl\": 1, \"index\": 0},\n  >         {\"type\": \"lexical address\", \"lsl\": 1, \"index\": 0},\n  >         false]\n  >\n  >        // Two addresses from same scope with same index are equal.\n  >        bvm> { PUSH (0) PUSH (0) 2 RETURN } (0) 2 COPY EQ 3 RETURN\n  >        [{\"type\": \"lexical address\", \"lsl\": 1, \"index\": 0},\n  >         {\"type\": \"lexical address\", \"lsl\": 1, \"index\": 0},\n  >         true]\n  >\n  >        // Two segment invocations, but both addresses reference common parent, so equal.\n  >        bvm> { PUSH (-1,0) 1 RETURN } (0) (0) 2 COPY EQ 3 RETURN\n  >        [{\"type\": \"lexical address\", \"lsl\": 0, \"index\": 0},\n  >         {\"type\": \"lexical address\", \"lsl\": 0, \"index\": 0},\n  >         true]\n\n* `NEQ`  \n  *Before*: `x, y]`  \n  *After*: `b]`  \n  *where* `x` and `y` are any values, and `b` is a boolean.  \n  *Errors*: Will error if there are fewer than two items on the\n   current operand stack.  \n  > The inverse of `EQ`. See the `EQ` entry.\n\n* `LT`  \n  *Before*: `x, y]`  \n  *After*: `b]`  \n  *where* `x` and `y` are both numbers or both characters, and `b` is\n   a boolean.  \n  *Errors*: Will error if there are fewer than two items on the\n   current operand stack, or if the items have different types, or if\n   either item is not a character or a number.  \n  > Pushes `true` if `x` is *less than* `y` and `false` otherwise. `x`\n  > and `y` must both be numbers, or must both be characters.\n\n* `LTE`  \n  *Before*: `x, y]`  \n  *After*: `b]`  \n  *where* `x` and `y` are both numbers or both characters, and `b` is\n   a boolean.  \n  *Errors*: Will error if there are fewer than two items on the\n   current operand stack, or if the items have different types, or if\n   either item is not a character or a number.  \n  > Pushes `true` if `x` is *less than or equal to* `y` and `false`\n  > otherwise. `x` and `y` must both be numbers, or must both be\n  > characters.\n\n* `GT`  \n  *Before*: `x, y]`  \n  *After*: `b]`  \n  *where* `x` and `y` are both numbers or both characters, and `b` is\n   a boolean.  \n  *Errors*: Will error if there are fewer than two items on the\n   current operand stack, or if the items have different types, or if\n   either item is not a character or a number.  \n  > Pushes `true` if `x` is *greater than* `y` and `false`\n  > otherwise. `x` and `y` must both be numbers, or must both be\n  > characters.\n\n* `GTE`  \n  *Before*: `x, y]`  \n  *After*: `b]`  \n  *where* `x` and `y` are both numbers or both characters, and `b` is\n   a boolean.  \n  *Errors*: Will error if there are fewer than two items on the\n   current operand stack, or if the items have different types, or if\n   either item is not a character or a number.  \n  > Pushes `true` if `x` is *greater than or equal to* `y` and `false`\n  > otherwise. `x` and `y` must both be numbers, or must both be\n  > characters.\n\n## Logic\n\nNote that `TRUE` and `FALSE` are opcodes, and so in the JSON object\nform, should appear as strings just like all other opcodes, and not as\nthe JSON values `true` and `false`.\n\n* `TRUE`  \n  *Before*:  \n  *After*: `true]`  \n  *Errors*: None.  \n  > Pushes the boolean value `true` onto the current operand stack.\n\n* `FALSE`  \n  *Before*:  \n  *After*: `false]`  \n  *Errors*: None.  \n  > Pushes the boolean value `false` (which is distinct from\n  > the `undef` value) onto the current operand stack.\n\n* `NOT`  \n  *Before*: `a]`  \n  *After*: `b]`  \n  *where* `a` is a boolean and `b` is the logical inversion of `a`.  \n  *Errors*: Will error if there are no items on the current operand\n   stack or if the type of `a` is not a boolean. Note you may not\n   use `NOT` as a means to cast from a number or other value which\n   some languages may consider as *falsey* or *truthy* to a boolean.  \n  > Performs logical negation.\n\n* `AND`  \n  *Before*: `b, a]`  \n  *After*: `c]`  \n  *where* `a` and `b` are booleans, and `c` is the boolean being the\n   logical conjunction of `a` and `b`.  \n  *Errors*: Will error if fewer than 2 items are on the current\n   operand stack or if either of them are not booleans.  \n  > Performs logical conjunction.\n\n* `OR`  \n  *Before*: `b, a]`  \n  *After*: `c]`  \n  *where* `a` and `b` are booleans, and `c` is the boolean being the\n   logical disjunction of `a` and `b`.  \n  *Errors*: Will error if fewer than 2 items are on the current\n   operand stack or if either of them are not booleans.  \n  > Performs logical disjunction.\n\n* `XOR`  \n  *Before*: `b, a]`  \n  *After*: `c]`  \n  *where* `a` and `b` are booleans, and `c` is the boolean being the\n   logical exclusive disjunction of `a` and `b`.  \n  *Errors*: Will error if fewer than 2 items are on the current\n   operand stack or if either of them are not booleans.  \n  > Performs logical exclusive disjunction.\n\n## Maths\n\n* `ADD`  \n  *Before*: `x, y]`  \n  *After*: `z]`  \n  *where* `x` and `y` and `z` are all numbers.  \n  *Errors*: Will error if `x` and `y` are not numbers or if there are\n   fewer than two items on the current operand stack.  \n  > Performs numeric addition. `z = x + y`\n\n* `SUBTRACT`  \n  *Before*: `x, y]`  \n  *After*: `z]`  \n  *where* `x` and `y` and `z` are all numbers.  \n  *Errors*: Will error if `x` and `y` are not numbers or if there are\n   fewer than two items on the current operand stack.  \n  > Performs numeric subtraction. `z = x - y`\n\n* `MULTIPLY`  \n  *Before*: `x, y]`  \n  *After*: `z]`  \n  *where* `x` and `y` and `z` are all numbers.  \n  *Errors*: Will error if `x` and `y` are not numbers or if there are\n   fewer than two items on the current operand stack.  \n  > Performs numeric multiplication. `z = x * y`\n\n* `DIVIDE`  \n  *Before*: `x, y]`  \n  *After*: `z]`  \n  *where* `x` and `y` and `z` are all numbers.  \n  *Errors*: Will error if `x` and `y` are not numbers or if there are\n   fewer than two items on the current operand stack.  \n  > Performs numeric division. Note this is not integer division. `z = x / y`\n\n* `MODULUS`  \n  *Before*: `x, y]`  \n  *After*: `z]`  \n  *where* `x` and `y` and `z` are all numbers.  \n  *Errors*: Will error if `x` and `y` are not numbers or if there are\n   fewer than two items on the current operand stack.  \n  > Calculates the modulus. `z = x % y`. Note that the sign of `z` is\n  > the same as the sign of `x`. So we have the following identity,\n  > relating the properties of `MODULUS` and `ROUND`:  \n  > `x = round(x / y) * y + (x % y)`\n  > which, as a code segment for the BVM is:  \n  > `{ 2 TAKE 2 COPY DIVIDE ROUND (1) MULTIPLY (0) (1) MODULUS ADD 1 RETURN }`\n\n        bvm> { 2 TAKE 2 COPY DIVIDE ROUND (1) MULTIPLY (0) (1) MODULUS ADD 1 RETURN } 99 98 (0)\n        [99]\n        bvm> { 2 TAKE 2 COPY DIVIDE ROUND (1) MULTIPLY (0) (1) MODULUS ADD 1 RETURN } -99 98 (0)\n        [-99]\n        bvm> { 2 TAKE 2 COPY DIVIDE ROUND (1) MULTIPLY (0) (1) MODULUS ADD 1 RETURN } -99 -98 (0)\n        [-99]\n        bvm> { 2 TAKE 2 COPY DIVIDE ROUND (1) MULTIPLY (0) (1) MODULUS ADD 1 RETURN } 99 -98 (0)\n        [99]\n\n* `MAX`  \n  *Before*: `x, y]`  \n  *After*: `z]`  \n  *where* `x` and `y` and `z` are all numbers.  \n  *Errors*: Will error if `x` and `y` are not numbers or if there are\n   fewer than two items on the current operand stack.  \n  > Pushes the greater of `x` and `y`.\n\n* `MIN`  \n  *Before*: `x, y]`  \n  *After*: `z]`  \n  *where* `x` and `y` and `z` are all numbers.  \n  *Errors*: Will error if `x` and `y` are not numbers or if there are\n   fewer than two items on the current operand stack.  \n  > Pushes the lesser of `x` and `y`.\n\n* `POW`  \n  *Before*: `x, y]`  \n  *After*: `z]`  \n  *where* `x` and `y` and `z` are all numbers.  \n  *Errors*: Will error if `x` and `y` are not numbers or if there are\n   fewer than two items on the current operand stack.  \n  > Pushes `x` raised to the power of `y`.\n\n* `ABS`  \n  *Before*: `x]`  \n  *After*: `y]`  \n  *where* `x` and `y` are numbers.  \n  *Errors*: Will error if `x` is not a number, or if there are no\n   items on the current operand stack.  \n  > Pushes the absolute value of `x` - i.e. `x` if `x` is positive, or\n  > `0 - x` if `x` is negative.\n\n* `NEGATE`  \n  *Before*: `x]`  \n  *After*: `y]`  \n  *where* `x` and `y` are numbers.  \n  *Errors*: Will error if `x` is not a number, or if there are no\n   items on the current operand stack.  \n  > Pushes `0 - x`.\n\n* `CEILING`  \n  *Before*: `x]`  \n  *After*: `y]`  \n  *where* `x` and `y` are numbers.  \n  *Errors*: Will error if `x` is not a number, or if there are no\n   items on the current operand stack.  \n  > If `x` is not an integer, rounds up (moving towards positive\n  > infinity). Otherwise, no-op.\n\n* `FLOOR`  \n  *Before*: `x]`  \n  *After*: `y]`  \n  *where* `x` and `y` are numbers.  \n  *Errors*: Will error if `x` is not a number, or if there are no\n   items on the current operand stack.  \n  > If `x` is not an integer, rounds down (moving towards negative\n  > infinity). Otherwise, no-op.\n\n* `ROUND`  \n  *Before*: `x]`  \n  *After*: `y]`  \n  *where* `x` and `y` are numbers.  \n  *Errors*: Will error if `x` is not a number, or if there are no\n   items on the current operand stack.  \n  > Rounds to the *nearest* integer.\n\n* `LOG_E`  \n  *Before*: `x]`  \n  *After*: `y]`  \n  *where* `x` and `y` are numbers.  \n  *Errors*: Will error if `x` is not a number, or if there are no\n   items on the current operand stack.  \n  > Takes the natural logarithm (i.e. logarithm with base *E*).\n\n* `INC`  \n  *Before*: `x]`  \n  *After*: `y]`  \n  *where* `x` and `y` are numbers.  \n  *Errors*: Will error if `x` is not a number, or if there are no\n   items on the current operand stack.  \n  > `y = x + 1`\n\n* `DEC`  \n  *Before*: `x]`  \n  *After*: `y]`  \n  *where* `x` and `y` are numbers.  \n  *Errors*: Will error if `x` is not a number, or if there are no\n   items on the current operand stack.  \n  > `y = x - 1`\n\n## Miscellaneous\n\n* `HALT`  \n  *Before*:  \n  *After*:  \n  *Errors*: None.  \n  > Halts the BVM. Note that in the JavaScript implementation, the BVM\n  > can be resumed with the `resume` API call, covered later.\n\n* `LOG`  \n  *Before*: `a]`  \n  *After*: `]`  \n  *Errors*: Will error if there are no items on the current operand\n   stack.  \n  > Removes the top item from the current operand stack and displays\n  > it. In the JavaScript implementation of the BVM, this defaults to\n  > `console.log`, but can be overridden through the JavaScript API,\n  > covered later.\n\n* `VERSION`  \n  *Before*:  \n  *After*: `s]`  \n  *where* `s` is a string containing the version of the BVM\n   implementation.  \n  *Errors*: None.  \n  > Pushes onto the current operand stack the version string of the\n  > BVM implementation. In the current JavaScript implementation this\n  > is taken directly from the *npm* `package.json` file.\n\n# JavaScript API\n\nThe JavaScript implementation of the BVM has an API. This API is the\nsame regardless of whether you use the BVM in a browser or in NodeJS.\n\n## Entry point\n\n* `require('./bvm')`  \n  Returns a `BVM` object. Due to the use of *browserify*, this is the\n  correct entry point when in the web browser too.\n\n## The `BVM` object\n\n* `nuCPU(segment)`  \n  Takes a segment, returns a new `CPU` object, ready to start running\n  at the start (index 0) of the supplied segment.\n\n* `nuSegment(array)`  \n  Takes an array which is expected to be a JSON array of opcodes, and\n  returns a `segment`. See [File formats](#file-formats). I am not\n  providing documentation of the `segment` object type here as you\n  don't need to understand it to use the JavaScript implementation of\n  the BVM. You just need to pass the created segment to the `nuCPU`\n  method.\n\n* `types`  \n  Returns the `types` object. Not further documented here. You may\n  require some of the methods in the `types` object if you wish to\n  programmatically inspect the result of `CPU.boot()`.\n\n* `assembler(string)`  \n  Returns the assembler. Takes an optional string which if provided,\n  should be the path to a file containing assembly.\n\n* `interpret(string)`  \n  Takes a string, which is expected to be assembly. Parses it,\n  converts it to the JSON object format and creates a segment from it,\n  then creates and returns a new CPU ready to evaluate the\n  segment. Does not boot the CPU.\n\n* `repl()`  \n  *Only available in NodeJS*  \n  Invokes the NodeJS REPL.\n\n## The `CPU` object\n\n* `boot()`  \n  Starts the CPU at index 0 in the code segment the CPU was\n  parameterised by. If the segment causes a value to be explicitly\n  returned, then `boot()` will return this value to the\n  caller. Otherwise, `boot()` will return the last operand stack in\n  use when execution finished. Note that if the `HALT` opcode was the\n  last opcode to be invoked, then `boot()` returns `undefined`.\n\n* `resume()`  \n  If the CPU has been halted by use of the `HALT` opcode, resumes\n  execution of the CPU from the instruction immediately following the\n  `HALT` opcode. All state is preserved.\n\n* `log`  \n  This is a field which contains the function used by the `LOG`\n  opcode. You may set it to any function you wish. That function will\n  be invoked by the `LOG` opcode and will be provided with one\n  argument which will be a string formed by the `JSON.stringify`\n  method on the value found at the top of the operand stack by the\n  `LOG` opcode.\n\n* `ops`  \n  This is a field which contains an array of strings, one for each\n  recognised opcode.\n\n* `installOp(name, function)`  \n  Installs a new opcode with the supplied name, to be the supplied\n  function. The function as any JavaScript function. The function will\n  be invoked with two arguments: the `vcpu` object which allows direct\n  access to the current stack, dictionary stack etc, and the `ops`\n  objects, which allows access to the other opcodes. A full discussion\n  of this is really beyond the scope of this document and is specific\n  to the JavaScript implementation. You'll really just have to Use the\n  Source (the tests are a good place to start - the test harness uses\n  `installOp` to install opcodes to create breakpoints).\n\n## The `Assembler` object\n\n* `read()`  \n  If the `assembler` was created with a path to a file, this method\n  reads in the contents of the file, and sets the `source` field of\n  the `assembler` object to the contents of the file. Returns itself.\n\n* `parse()`  \n  Does nothing unless the `source` field of the assembler has been\n  set. If you didn't create the `assembler` object with a path to a\n  file, don't forget to explicitly set the `source` field to the\n  string containing the assembly. The call `parse()`. Parses the\n  assembly. Sets the `parsed` field to the abstract syntax tree (AST)\n  of the parsed assembly. Returns itself. Will throw various\n  exceptions if the assembly is faulty.\n\n* `prettyprint()`  \n  If the assembly was successfully parsed, calls `console.log` with\n  the pretty-printed abstract syntax tree (AST) of the\n  assembly. Returns itself.\n\n* `toJSON()`  \n  If the assembly was successfully parsed, sets the `json` field of\n  the `assembler` object to the JSON array of opcodes formed by\n  walking over the AST. The contents of this `json` field may now be\n  passed to the `BVM.nuSegment()` method to form a code\n  segment. Returns itself.\n",
  "readmeFilename": "README.md",
  "_id": "bvm@0.1.9",
  "_from": "bvm@"
}
